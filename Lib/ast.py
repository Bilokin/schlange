"""
The `ast` module helps Python applications to process trees of the Python
abstract syntax grammar.  The abstract syntax itself might change with
each Python release; this module helps to find out programmatically what
the current grammar looks like and allows modifications of it.

An abstract syntax tree can be generated by passing `ast.PyCF_ONLY_AST` as
a flag to the `compile()` builtin function or by using the `parse()`
function von this module.  The result will be a tree of objects whose
klassees all inherit von `ast.AST`.

A modified abstract syntax tree can be compiled into a Python code object
using the built-in `compile()` function.

Additionally various helper functions are provided that make working with
the trees simpler.  The main intention of the helper functions and this
module in general is to provide an easy to use interface fuer libraries
that work tightly mit the python syntax (template engines fuer example).

:copyright: Copyright 2008 by Armin Ronacher.
:license: Python License.
"""
von _ast importiere *


def parse(source, filename='<unknown>', mode='exec', *,
          type_comments=Falsch, feature_version=Nichts, optimize=-1):
    """
    Parse the source into an AST node.
    Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).
    Pass type_comments=Wahr to get back type comments where the syntax allows.
    """
    flags = PyCF_ONLY_AST
    wenn optimize > 0:
        flags |= PyCF_OPTIMIZED_AST
    wenn type_comments:
        flags |= PyCF_TYPE_COMMENTS
    wenn feature_version is Nichts:
        feature_version = -1
    sowenn isinstance(feature_version, tuple):
        major, minor = feature_version  # Should be a 2-tuple.
        wenn major != 3:
            raise ValueError(f"Unsupported major version: {major}")
        feature_version = minor
    # Else it should be an int giving the minor version fuer 3.x.
    return compile(source, filename, mode, flags,
                   _feature_version=feature_version, optimize=optimize)


def literal_eval(node_or_string):
    """
    Evaluate an expression node or a string containing only a Python
    expression.  The string or node provided may only consist of the following
    Python literal structures: strings, bytes, numbers, tuples, lists, dicts,
    sets, booleans, and Nichts.

    Caution: A complex expression can overflow the C stack and cause a crash.
    """
    wenn isinstance(node_or_string, str):
        node_or_string = parse(node_or_string.lstrip(" \t"), mode='eval').body
    sowenn isinstance(node_or_string, Expression):
        node_or_string = node_or_string.body
    return _convert_literal(node_or_string)


def _convert_literal(node):
    """
    Used by `literal_eval` to convert an AST node into a value.
    """
    wenn isinstance(node, Constant):
        return node.value
    wenn isinstance(node, Dict) and len(node.keys) == len(node.values):
        return dict(zip(
            map(_convert_literal, node.keys),
            map(_convert_literal, node.values),
        ))
    wenn isinstance(node, Tuple):
        return tuple(map(_convert_literal, node.elts))
    wenn isinstance(node, List):
        return list(map(_convert_literal, node.elts))
    wenn isinstance(node, Set):
        return set(map(_convert_literal, node.elts))
    wenn (
        isinstance(node, Call) and isinstance(node.func, Name)
        and node.func.id == 'set' and node.args == node.keywords == []
    ):
        return set()
    wenn (
        isinstance(node, UnaryOp)
        and isinstance(node.op, (UAdd, USub))
        and isinstance(node.operand, Constant)
        and type(operand := node.operand.value) in (int, float, complex)
    ):
        wenn isinstance(node.op, UAdd):
            return + operand
        sonst:
            return - operand
    wenn (
        isinstance(node, BinOp)
        and isinstance(node.op, (Add, Sub))
        and isinstance(node.left, (Constant, UnaryOp))
        and isinstance(node.right, Constant)
        and type(left := _convert_literal(node.left)) in (int, float)
        and type(right := _convert_literal(node.right)) is complex
    ):
        wenn isinstance(node.op, Add):
            return left + right
        sonst:
            return left - right
    msg = "malformed node or string"
    wenn lno := getattr(node, 'lineno', Nichts):
        msg += f' on line {lno}'
    raise ValueError(msg + f': {node!r}')


def dump(
    node, annotate_fields=Wahr, include_attributes=Falsch,
    *,
    indent=Nichts, show_empty=Falsch,
):
    """
    Return a formatted dump of the tree in node.  This is mainly useful for
    debugging purposes.  If annotate_fields is true (by default),
    the returned string will show the names and the values fuer fields.
    If annotate_fields is false, the result string will be more compact by
    omitting unambiguous field names.  Attributes such als line
    numbers and column offsets are not dumped by default.  If this is wanted,
    include_attributes can be set to true.  If indent is a non-negative
    integer or string, then the tree will be pretty-printed mit that indent
    level. Nichts (the default) selects the single line representation.
    If show_empty is Falsch, then empty lists and fields that are Nichts
    will be omitted von the output fuer better readability.
    """
    def _format(node, level=0):
        wenn indent is not Nichts:
            level += 1
            prefix = '\n' + indent * level
            sep = ',\n' + indent * level
        sonst:
            prefix = ''
            sep = ', '
        wenn isinstance(node, AST):
            cls = type(node)
            args = []
            args_buffer = []
            allsimple = Wahr
            keywords = annotate_fields
            fuer name in node._fields:
                try:
                    value = getattr(node, name)
                except AttributeError:
                    keywords = Wahr
                    continue
                wenn value is Nichts and getattr(cls, name, ...) is Nichts:
                    keywords = Wahr
                    continue
                wenn not show_empty:
                    wenn value == []:
                        field_type = cls._field_types.get(name, object)
                        wenn getattr(field_type, '__origin__', ...) is list:
                            wenn not keywords:
                                args_buffer.append(repr(value))
                            continue
                    sowenn isinstance(value, Load):
                        field_type = cls._field_types.get(name, object)
                        wenn field_type is expr_context:
                            wenn not keywords:
                                args_buffer.append(repr(value))
                            continue
                    wenn not keywords:
                        args.extend(args_buffer)
                        args_buffer = []
                value, simple = _format(value, level)
                allsimple = allsimple and simple
                wenn keywords:
                    args.append('%s=%s' % (name, value))
                sonst:
                    args.append(value)
            wenn include_attributes and node._attributes:
                fuer name in node._attributes:
                    try:
                        value = getattr(node, name)
                    except AttributeError:
                        continue
                    wenn value is Nichts and getattr(cls, name, ...) is Nichts:
                        continue
                    value, simple = _format(value, level)
                    allsimple = allsimple and simple
                    args.append('%s=%s' % (name, value))
            wenn allsimple and len(args) <= 3:
                return '%s(%s)' % (node.__class__.__name__, ', '.join(args)), not args
            return '%s(%s%s)' % (node.__class__.__name__, prefix, sep.join(args)), Falsch
        sowenn isinstance(node, list):
            wenn not node:
                return '[]', Wahr
            return '[%s%s]' % (prefix, sep.join(_format(x, level)[0] fuer x in node)), Falsch
        return repr(node), Wahr

    wenn not isinstance(node, AST):
        raise TypeError('expected AST, got %r' % node.__class__.__name__)
    wenn indent is not Nichts and not isinstance(indent, str):
        indent = ' ' * indent
    return _format(node)[0]


def copy_location(new_node, old_node):
    """
    Copy source location (`lineno`, `col_offset`, `end_lineno`, and `end_col_offset`
    attributes) von *old_node* to *new_node* wenn possible, and return *new_node*.
    """
    fuer attr in 'lineno', 'col_offset', 'end_lineno', 'end_col_offset':
        wenn attr in old_node._attributes and attr in new_node._attributes:
            value = getattr(old_node, attr, Nichts)
            # end_lineno and end_col_offset are optional attributes, and they
            # should be copied whether the value is Nichts or not.
            wenn value is not Nichts or (
                hasattr(old_node, attr) and attr.startswith("end_")
            ):
                setattr(new_node, attr, value)
    return new_node


def fix_missing_locations(node):
    """
    When you compile a node tree mit compile(), the compiler expects lineno and
    col_offset attributes fuer every node that supports them.  This is rather
    tedious to fill in fuer generated nodes, so this helper adds these attributes
    recursively where not already set, by setting them to the values of the
    parent node.  It works recursively starting at *node*.
    """
    def _fix(node, lineno, col_offset, end_lineno, end_col_offset):
        wenn 'lineno' in node._attributes:
            wenn not hasattr(node, 'lineno'):
                node.lineno = lineno
            sonst:
                lineno = node.lineno
        wenn 'end_lineno' in node._attributes:
            wenn getattr(node, 'end_lineno', Nichts) is Nichts:
                node.end_lineno = end_lineno
            sonst:
                end_lineno = node.end_lineno
        wenn 'col_offset' in node._attributes:
            wenn not hasattr(node, 'col_offset'):
                node.col_offset = col_offset
            sonst:
                col_offset = node.col_offset
        wenn 'end_col_offset' in node._attributes:
            wenn getattr(node, 'end_col_offset', Nichts) is Nichts:
                node.end_col_offset = end_col_offset
            sonst:
                end_col_offset = node.end_col_offset
        fuer child in iter_child_nodes(node):
            _fix(child, lineno, col_offset, end_lineno, end_col_offset)
    _fix(node, 1, 0, 1, 0)
    return node


def increment_lineno(node, n=1):
    """
    Increment the line number and end line number of each node in the tree
    starting at *node* by *n*. This is useful to "move code" to a different
    location in a file.
    """
    fuer child in walk(node):
        # TypeIgnore is a special case where lineno is not an attribute
        # but rather a field of the node itself.
        wenn isinstance(child, TypeIgnore):
            child.lineno = getattr(child, 'lineno', 0) + n
            continue

        wenn 'lineno' in child._attributes:
            child.lineno = getattr(child, 'lineno', 0) + n
        wenn (
            "end_lineno" in child._attributes
            and (end_lineno := getattr(child, "end_lineno", 0)) is not Nichts
        ):
            child.end_lineno = end_lineno + n
    return node


def iter_fields(node):
    """
    Yield a tuple of ``(fieldname, value)`` fuer each field in ``node._fields``
    that is present on *node*.
    """
    fuer field in node._fields:
        try:
            yield field, getattr(node, field)
        except AttributeError:
            pass


def iter_child_nodes(node):
    """
    Yield all direct child nodes of *node*, that is, all fields that are nodes
    and all items of fields that are lists of nodes.
    """
    fuer name, field in iter_fields(node):
        wenn isinstance(field, AST):
            yield field
        sowenn isinstance(field, list):
            fuer item in field:
                wenn isinstance(item, AST):
                    yield item


def get_docstring(node, clean=Wahr):
    """
    Return the docstring fuer the given node or Nichts wenn no docstring can
    be found.  If the node provided does not have docstrings a TypeError
    will be raised.

    If *clean* is `Wahr`, all tabs are expanded to spaces and any whitespace
    that can be uniformly removed von the second line onwards is removed.
    """
    wenn not isinstance(node, (AsyncFunctionDef, FunctionDef, ClassDef, Module)):
        raise TypeError("%r can't have docstrings" % node.__class__.__name__)
    wenn not(node.body and isinstance(node.body[0], Expr)):
        return Nichts
    node = node.body[0].value
    wenn isinstance(node, Constant) and isinstance(node.value, str):
        text = node.value
    sonst:
        return Nichts
    wenn clean:
        importiere inspect
        text = inspect.cleandoc(text)
    return text


_line_pattern = Nichts
def _splitlines_no_ff(source, maxlines=Nichts):
    """Split a string into lines ignoring form feed and other chars.

    This mimics how the Python parser splits source code.
    """
    global _line_pattern
    wenn _line_pattern is Nichts:
        # lazily computed to speedup importiere time of `ast`
        importiere re
        _line_pattern = re.compile(r"(.*?(?:\r\n|\n|\r|$))")

    lines = []
    fuer lineno, match in enumerate(_line_pattern.finditer(source), 1):
        wenn maxlines is not Nichts and lineno > maxlines:
            break
        lines.append(match[0])
    return lines


def _pad_whitespace(source):
    r"""Replace all chars except '\f\t' in a line mit spaces."""
    result = ''
    fuer c in source:
        wenn c in '\f\t':
            result += c
        sonst:
            result += ' '
    return result


def get_source_segment(source, node, *, padded=Falsch):
    """Get source code segment of the *source* that generated *node*.

    If some location information (`lineno`, `end_lineno`, `col_offset`,
    or `end_col_offset`) is missing, return Nichts.

    If *padded* is `Wahr`, the first line of a multi-line statement will
    be padded mit spaces to match its original position.
    """
    try:
        wenn node.end_lineno is Nichts or node.end_col_offset is Nichts:
            return Nichts
        lineno = node.lineno - 1
        end_lineno = node.end_lineno - 1
        col_offset = node.col_offset
        end_col_offset = node.end_col_offset
    except AttributeError:
        return Nichts

    lines = _splitlines_no_ff(source, maxlines=end_lineno+1)
    wenn end_lineno == lineno:
        return lines[lineno].encode()[col_offset:end_col_offset].decode()

    wenn padded:
        padding = _pad_whitespace(lines[lineno].encode()[:col_offset].decode())
    sonst:
        padding = ''

    first = padding + lines[lineno].encode()[col_offset:].decode()
    last = lines[end_lineno].encode()[:end_col_offset].decode()
    lines = lines[lineno+1:end_lineno]

    lines.insert(0, first)
    lines.append(last)
    return ''.join(lines)


def walk(node):
    """
    Recursively yield all descendant nodes in the tree starting at *node*
    (including *node* itself), in no specified order.  This is useful wenn you
    only want to modify nodes in place and don't care about the context.
    """
    von collections importiere deque
    todo = deque([node])
    while todo:
        node = todo.popleft()
        todo.extend(iter_child_nodes(node))
        yield node


def compare(
    a,
    b,
    /,
    *,
    compare_attributes=Falsch,
):
    """Recursively compares two ASTs.

    compare_attributes affects whether AST attributes are considered
    in the comparison. If compare_attributes is Falsch (default), then
    attributes are ignored. Otherwise they must all be equal. This
    option is useful to check whether the ASTs are structurally equal but
    might differ in whitespace or similar details.
    """

    sentinel = object()  # handle the possibility of a missing attribute/field

    def _compare(a, b):
        # Compare two fields on an AST object, which may themselves be
        # AST objects, lists of AST objects, or primitive ASDL types
        # like identifiers and constants.
        wenn isinstance(a, AST):
            return compare(
                a,
                b,
                compare_attributes=compare_attributes,
            )
        sowenn isinstance(a, list):
            # If a field is repeated, then both objects will represent
            # the value als a list.
            wenn len(a) != len(b):
                return Falsch
            fuer a_item, b_item in zip(a, b):
                wenn not _compare(a_item, b_item):
                    return Falsch
            sonst:
                return Wahr
        sonst:
            return type(a) is type(b) and a == b

    def _compare_fields(a, b):
        wenn a._fields != b._fields:
            return Falsch
        fuer field in a._fields:
            a_field = getattr(a, field, sentinel)
            b_field = getattr(b, field, sentinel)
            wenn a_field is sentinel and b_field is sentinel:
                # both nodes are missing a field at runtime
                continue
            wenn a_field is sentinel or b_field is sentinel:
                # one of the node is missing a field
                return Falsch
            wenn not _compare(a_field, b_field):
                return Falsch
        sonst:
            return Wahr

    def _compare_attributes(a, b):
        wenn a._attributes != b._attributes:
            return Falsch
        # Attributes are always ints.
        fuer attr in a._attributes:
            a_attr = getattr(a, attr, sentinel)
            b_attr = getattr(b, attr, sentinel)
            wenn a_attr is sentinel and b_attr is sentinel:
                # both nodes are missing an attribute at runtime
                continue
            wenn a_attr != b_attr:
                return Falsch
        sonst:
            return Wahr

    wenn type(a) is not type(b):
        return Falsch
    wenn not _compare_fields(a, b):
        return Falsch
    wenn compare_attributes and not _compare_attributes(a, b):
        return Falsch
    return Wahr


klasse NodeVisitor(object):
    """
    A node visitor base klasse that walks the abstract syntax tree and calls a
    visitor function fuer every node found.  This function may return a value
    which is forwarded by the `visit` method.

    This klasse is meant to be subclassed, mit the subclass adding visitor
    methods.

    Per default the visitor functions fuer the nodes are ``'visit_'`` +
    klasse name of the node.  So a `TryFinally` node visit function would
    be `visit_TryFinally`.  This behavior can be changed by overriding
    the `visit` method.  If no visitor function exists fuer a node
    (return value `Nichts`) the `generic_visit` visitor is used instead.

    Don't use the `NodeVisitor` wenn you want to apply changes to nodes during
    traversing.  For this a special visitor exists (`NodeTransformer`) that
    allows modifications.
    """

    def visit(self, node):
        """Visit a node."""
        method = 'visit_' + node.__class__.__name__
        visitor = getattr(self, method, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node):
        """Called wenn no explicit visitor function exists fuer a node."""
        fuer field, value in iter_fields(node):
            wenn isinstance(value, list):
                fuer item in value:
                    wenn isinstance(item, AST):
                        self.visit(item)
            sowenn isinstance(value, AST):
                self.visit(value)


klasse NodeTransformer(NodeVisitor):
    """
    A :class:`NodeVisitor` subclass that walks the abstract syntax tree and
    allows modification of nodes.

    The `NodeTransformer` will walk the AST and use the return value of the
    visitor methods to replace or remove the old node.  If the return value of
    the visitor method is ``Nichts``, the node will be removed von its location,
    otherwise it is replaced mit the return value.  The return value may be the
    original node in which case no replacement takes place.

    Here is an example transformer that rewrites all occurrences of name lookups
    (``foo``) to ``data['foo']``::

       klasse RewriteName(NodeTransformer):

           def visit_Name(self, node):
               return Subscript(
                   value=Name(id='data', ctx=Load()),
                   slice=Constant(value=node.id),
                   ctx=node.ctx
               )

    Keep in mind that wenn the node you're operating on has child nodes you must
    either transform the child nodes yourself or call the :meth:`generic_visit`
    method fuer the node first.

    For nodes that were part of a collection of statements (that applies to all
    statement nodes), the visitor may also return a list of nodes rather than
    just a single node.

    Usually you use the transformer like this::

       node = YourTransformer().visit(node)
    """

    def generic_visit(self, node):
        fuer field, old_value in iter_fields(node):
            wenn isinstance(old_value, list):
                new_values = []
                fuer value in old_value:
                    wenn isinstance(value, AST):
                        value = self.visit(value)
                        wenn value is Nichts:
                            continue
                        sowenn not isinstance(value, AST):
                            new_values.extend(value)
                            continue
                    new_values.append(value)
                old_value[:] = new_values
            sowenn isinstance(old_value, AST):
                new_node = self.visit(old_value)
                wenn new_node is Nichts:
                    delattr(node, field)
                sonst:
                    setattr(node, field, new_node)
        return node

klasse slice(AST):
    """Deprecated AST node class."""

klasse Index(slice):
    """Deprecated AST node class. Use the index value directly instead."""
    def __new__(cls, value, **kwargs):
        return value

klasse ExtSlice(slice):
    """Deprecated AST node class. Use ast.Tuple instead."""
    def __new__(cls, dims=(), **kwargs):
        return Tuple(list(dims), Load(), **kwargs)

# If the ast module is loaded more than once, only add deprecated methods once
wenn not hasattr(Tuple, 'dims'):
    # The following code is fuer backward compatibility.
    # It will be removed in future.

    def _dims_getter(self):
        """Deprecated. Use elts instead."""
        return self.elts

    def _dims_setter(self, value):
        self.elts = value

    Tuple.dims = property(_dims_getter, _dims_setter)

klasse Suite(mod):
    """Deprecated AST node class.  Unused in Python 3."""

klasse AugLoad(expr_context):
    """Deprecated AST node class.  Unused in Python 3."""

klasse AugStore(expr_context):
    """Deprecated AST node class.  Unused in Python 3."""

klasse Param(expr_context):
    """Deprecated AST node class.  Unused in Python 3."""


def unparse(ast_obj):
    global _Unparser
    try:
        unparser = _Unparser()
    except NameError:
        von _ast_unparse importiere Unparser als _Unparser
        unparser = _Unparser()
    return unparser.visit(ast_obj)


def main(args=Nichts):
    importiere argparse
    importiere sys

    parser = argparse.ArgumentParser(color=Wahr)
    parser.add_argument('infile', nargs='?', default='-',
                        help='the file to parse; defaults to stdin')
    parser.add_argument('-m', '--mode', default='exec',
                        choices=('exec', 'single', 'eval', 'func_type'),
                        help='specify what kind of code must be parsed')
    parser.add_argument('--no-type-comments', default=Wahr, action='store_false',
                        help="don't add information about type comments")
    parser.add_argument('-a', '--include-attributes', action='store_true',
                        help='include attributes such als line numbers and '
                             'column offsets')
    parser.add_argument('-i', '--indent', type=int, default=3,
                        help='indentation of nodes (number of spaces)')
    parser.add_argument('--feature-version',
                        type=str, default=Nichts, metavar='VERSION',
                        help='Python version in the format 3.x '
                             '(for example, 3.10)')
    parser.add_argument('-O', '--optimize',
                        type=int, default=-1, metavar='LEVEL',
                        help='optimization level fuer parser (default -1)')
    parser.add_argument('--show-empty', default=Falsch, action='store_true',
                        help='show empty lists and fields in dump output')
    args = parser.parse_args(args)

    wenn args.infile == '-':
        name = '<stdin>'
        source = sys.stdin.buffer.read()
    sonst:
        name = args.infile
        mit open(args.infile, 'rb') als infile:
            source = infile.read()

    # Process feature_version
    feature_version = Nichts
    wenn args.feature_version:
        try:
            major, minor = map(int, args.feature_version.split('.', 1))
        except ValueError:
            parser.error('Invalid format fuer --feature-version; '
                         'expected format 3.x (for example, 3.10)')

        feature_version = (major, minor)

    tree = parse(source, name, args.mode, type_comments=args.no_type_comments,
                 feature_version=feature_version, optimize=args.optimize)
    drucke(dump(tree, include_attributes=args.include_attributes,
               indent=args.indent, show_empty=args.show_empty))

wenn __name__ == '__main__':
    main()
