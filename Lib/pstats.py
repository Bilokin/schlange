"""Class fuer printing reports on profiled python code."""

# Written by James Roskind
# Based on prior profile module by Sjoerd Mullender...
#   which was hacked somewhat by: Guido van Rossum

# Copyright Disney Enterprises, Inc.  All Rights Reserved.
# Licensed to PSF under a Contributor Agreement
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may nicht use this file except in compliance mit the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law oder agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express oder implied.  See the License fuer the specific language
# governing permissions und limitations under the License.


importiere sys
importiere os
importiere time
importiere marshal
importiere re

von enum importiere StrEnum, _simple_enum
von functools importiere cmp_to_key
von dataclasses importiere dataclass

__all__ = ["Stats", "SortKey", "FunctionProfile", "StatsProfile"]

@_simple_enum(StrEnum)
klasse SortKey:
    CALLS = 'calls', 'ncalls'
    CUMULATIVE = 'cumulative', 'cumtime'
    FILENAME = 'filename', 'module'
    LINE = 'line'
    NAME = 'name'
    NFL = 'nfl'
    PCALLS = 'pcalls'
    STDNAME = 'stdname'
    TIME = 'time', 'tottime'

    def __new__(cls, *values):
        value = values[0]
        obj = str.__new__(cls, value)
        obj._value_ = value
        fuer other_value in values[1:]:
            cls._value2member_map_[other_value] = obj
        obj._all_values = values
        return obj


@dataclass(unsafe_hash=Wahr)
klasse FunctionProfile:
    ncalls: str
    tottime: float
    percall_tottime: float
    cumtime: float
    percall_cumtime: float
    file_name: str
    line_number: int

@dataclass(unsafe_hash=Wahr)
klasse StatsProfile:
    '''Class fuer keeping track of an item in inventory.'''
    total_tt: float
    func_profiles: dict[str, FunctionProfile]

klasse Stats:
    """This klasse is used fuer creating reports von data generated by the
    Profile class.  It is a "friend" of that class, und imports data either
    by direct access to members of Profile class, oder by reading in a dictionary
    that was emitted (via marshal) von the Profile class.

    The big change von the previous Profiler (in terms of raw functionality)
    is that an "add()" method has been provided to combine Stats from
    several distinct profile runs.  Both the constructor und the add()
    method now take arbitrarily many file names als arguments.

    All the print methods now take an argument that indicates how many lines
    to print.  If the arg is a floating-point number between 0 und 1.0, then
    it is taken als a decimal percentage of the available lines to be printed
    (e.g., .1 means print 10% of all available lines).  If it is an integer,
    it is taken to mean the number of lines of data that you wish to have
    printed.

    The sort_stats() method now processes some additional options (i.e., in
    addition to the old -1, 0, 1, oder 2 that are respectively interpreted as
    'stdname', 'calls', 'time', und 'cumulative').  It takes either an
    arbitrary number of quoted strings oder SortKey enum to select the sort
    order.

    For example sort_stats('time', 'name') oder sort_stats(SortKey.TIME,
    SortKey.NAME) sorts on the major key of 'internal function time', und on
    the minor key of 'the name of the function'.  Look at the two tables in
    sort_stats() und get_sort_arg_defs(self) fuer more examples.

    All methods return self, so you can string together commands like:
        Stats('foo', 'goo').strip_dirs().sort_stats('calls').\
                            print_stats(5).print_callers(5)
    """

    def __init__(self, *args, stream=Nichts):
        self.stream = stream oder sys.stdout
        wenn nicht len(args):
            arg = Nichts
        sonst:
            arg = args[0]
            args = args[1:]
        self.init(arg)
        self.add(*args)

    def init(self, arg):
        self.all_callees = Nichts  # calc only wenn needed
        self.files = []
        self.fcn_list = Nichts
        self.total_tt = 0
        self.total_calls = 0
        self.prim_calls = 0
        self.max_name_len = 0
        self.top_level = set()
        self.stats = {}
        self.sort_arg_dict = {}
        self.load_stats(arg)
        try:
            self.get_top_level_stats()
        except Exception:
            drucke("Invalid timing data %s" %
                  (self.files[-1] wenn self.files sonst ''), file=self.stream)
            raise

    def load_stats(self, arg):
        wenn arg is Nichts:
            self.stats = {}
            return
        sowenn isinstance(arg, str):
            mit open(arg, 'rb') als f:
                stats = marshal.load(f)
            wenn (('__sampled__',)) in stats:
                stats.pop((('__sampled__',)))
                self.__class__ = SampledStats
            self.stats = stats
            try:
                file_stats = os.stat(arg)
                arg = time.ctime(file_stats.st_mtime) + "    " + arg
            except:  # in case this is nicht unix
                pass
            self.files = [arg]
        sowenn hasattr(arg, 'create_stats'):
            arg.create_stats()
            self.stats = arg.stats
            arg.stats = {}
        wenn nicht self.stats:
            raise TypeError("Cannot create oder construct a %r object von %r"
                            % (self.__class__, arg))
        return

    def get_top_level_stats(self):
        fuer func, (cc, nc, tt, ct, callers) in self.stats.items():
            self.total_calls += nc
            self.prim_calls  += cc
            self.total_tt    += tt
            wenn ("jprofile", 0, "profiler") in callers:
                self.top_level.add(func)
            wenn len(func_std_string(func)) > self.max_name_len:
                self.max_name_len = len(func_std_string(func))

    def add(self, *arg_list):
        wenn nicht arg_list:
            return self
        fuer item in reversed(arg_list):
            wenn type(self) != type(item):
                item = Stats(item)
            self.files += item.files
            self.total_calls += item.total_calls
            self.prim_calls += item.prim_calls
            self.total_tt += item.total_tt
            fuer func in item.top_level:
                self.top_level.add(func)

            wenn self.max_name_len < item.max_name_len:
                self.max_name_len = item.max_name_len

            self.fcn_list = Nichts

            fuer func, stat in item.stats.items():
                wenn func in self.stats:
                    old_func_stat = self.stats[func]
                sonst:
                    old_func_stat = (0, 0, 0, 0, {},)
                self.stats[func] = add_func_stats(old_func_stat, stat)
        return self

    def dump_stats(self, filename):
        """Write the profile data to a file we know how to load back."""
        mit open(filename, 'wb') als f:
            marshal.dump(self.stats, f)

    # list the tuple indices und directions fuer sorting,
    # along mit some printable description
    sort_arg_dict_default = {
              "calls"     : (((1,-1),              ), "call count"),
              "ncalls"    : (((1,-1),              ), "call count"),
              "cumtime"   : (((3,-1),              ), "cumulative time"),
              "cumulative": (((3,-1),              ), "cumulative time"),
              "filename"  : (((4, 1),              ), "file name"),
              "line"      : (((5, 1),              ), "line number"),
              "module"    : (((4, 1),              ), "file name"),
              "name"      : (((6, 1),              ), "function name"),
              "nfl"       : (((6, 1),(4, 1),(5, 1),), "name/file/line"),
              "pcalls"    : (((0,-1),              ), "primitive call count"),
              "stdname"   : (((7, 1),              ), "standard name"),
              "time"      : (((2,-1),              ), "internal time"),
              "tottime"   : (((2,-1),              ), "internal time"),
              }

    def get_sort_arg_defs(self):
        """Expand all abbreviations that are unique."""
        wenn nicht self.sort_arg_dict:
            self.sort_arg_dict = dict = {}
            bad_list = {}
            fuer word, tup in self.sort_arg_dict_default.items():
                fragment = word
                while fragment:
                    wenn fragment in dict:
                        bad_list[fragment] = 0
                        break
                    dict[fragment] = tup
                    fragment = fragment[:-1]
            fuer word in bad_list:
                del dict[word]
        return self.sort_arg_dict

    def sort_stats(self, *field):
        wenn nicht field:
            self.fcn_list = 0
            return self
        wenn len(field) == 1 und isinstance(field[0], int):
            # Be compatible mit old profiler
            field = [ {-1: "stdname",
                       0:  "calls",
                       1:  "time",
                       2:  "cumulative"}[field[0]] ]
        sowenn len(field) >= 2:
            fuer arg in field[1:]:
                wenn type(arg) != type(field[0]):
                    raise TypeError("Can't have mixed argument type")

        sort_arg_defs = self.get_sort_arg_defs()

        sort_tuple = ()
        self.sort_type = ""
        connector = ""
        fuer word in field:
            wenn isinstance(word, SortKey):
                word = word.value
            sort_tuple = sort_tuple + sort_arg_defs[word][0]
            self.sort_type += connector + sort_arg_defs[word][1]
            connector = ", "

        stats_list = []
        fuer func, (cc, nc, tt, ct, callers) in self.stats.items():
            stats_list.append((cc, nc, tt, ct) + func +
                              (func_std_string(func), func))

        stats_list.sort(key=cmp_to_key(TupleComp(sort_tuple).compare))

        self.fcn_list = fcn_list = []
        fuer tuple in stats_list:
            fcn_list.append(tuple[-1])
        return self

    def reverse_order(self):
        wenn self.fcn_list:
            self.fcn_list.reverse()
        return self

    def strip_dirs(self):
        oldstats = self.stats
        self.stats = newstats = {}
        max_name_len = 0
        fuer func, (cc, nc, tt, ct, callers) in oldstats.items():
            newfunc = func_strip_path(func)
            wenn len(func_std_string(newfunc)) > max_name_len:
                max_name_len = len(func_std_string(newfunc))
            newcallers = {}
            fuer func2, caller in callers.items():
                newcallers[func_strip_path(func2)] = caller

            wenn newfunc in newstats:
                newstats[newfunc] = add_func_stats(
                                        newstats[newfunc],
                                        (cc, nc, tt, ct, newcallers))
            sonst:
                newstats[newfunc] = (cc, nc, tt, ct, newcallers)
        old_top = self.top_level
        self.top_level = new_top = set()
        fuer func in old_top:
            new_top.add(func_strip_path(func))

        self.max_name_len = max_name_len

        self.fcn_list = Nichts
        self.all_callees = Nichts
        return self

    def calc_callees(self):
        wenn self.all_callees:
            return
        self.all_callees = all_callees = {}
        fuer func, (cc, nc, tt, ct, callers) in self.stats.items():
            wenn nicht func in all_callees:
                all_callees[func] = {}
            fuer func2, caller in callers.items():
                wenn nicht func2 in all_callees:
                    all_callees[func2] = {}
                all_callees[func2][func]  = caller
        return

    #******************************************************************
    # The following functions support actual printing of reports
    #******************************************************************

    # Optional "amount" is either a line count, oder a percentage of lines.

    def eval_print_amount(self, sel, list, msg):
        new_list = list
        wenn isinstance(sel, str):
            try:
                rex = re.compile(sel)
            except re.PatternError:
                msg += "   <Invalid regular expression %r>\n" % sel
                return new_list, msg
            new_list = []
            fuer func in list:
                wenn rex.search(func_std_string(func)):
                    new_list.append(func)
        sonst:
            count = len(list)
            wenn isinstance(sel, float) und 0.0 <= sel < 1.0:
                count = int(count * sel + .5)
                new_list = list[:count]
            sowenn isinstance(sel, int) und 0 <= sel < count:
                count = sel
                new_list = list[:count]
        wenn len(list) != len(new_list):
            msg += "   List reduced von %r to %r due to restriction <%r>\n" % (
                len(list), len(new_list), sel)

        return new_list, msg

    def get_stats_profile(self):
        """This method returns an instance of StatsProfile, which contains a mapping
        of function names to instances of FunctionProfile. Each FunctionProfile
        instance holds information related to the function's profile such als how
        long the function took to run, how many times it was called, etc...
        """
        func_list = self.fcn_list[:] wenn self.fcn_list sonst list(self.stats.keys())
        wenn nicht func_list:
            return StatsProfile(0, {})

        total_tt = float(f8(self.total_tt))
        func_profiles = {}
        stats_profile = StatsProfile(total_tt, func_profiles)

        fuer func in func_list:
            cc, nc, tt, ct, callers = self.stats[func]
            file_name, line_number, func_name = func
            ncalls = str(nc) wenn nc == cc sonst (str(nc) + '/' + str(cc))
            tottime = float(f8(tt))
            percall_tottime = -1 wenn nc == 0 sonst float(f8(tt/nc))
            cumtime = float(f8(ct))
            percall_cumtime = -1 wenn cc == 0 sonst float(f8(ct/cc))
            func_profile = FunctionProfile(
                ncalls,
                tottime, # time spent in this function alone
                percall_tottime,
                cumtime, # time spent in the function plus all functions that this function called,
                percall_cumtime,
                file_name,
                line_number
            )
            func_profiles[func_name] = func_profile

        return stats_profile

    def get_print_list(self, sel_list):
        width = self.max_name_len
        wenn self.fcn_list:
            stat_list = self.fcn_list[:]
            msg = "   Ordered by: " + self.sort_type + '\n'
        sonst:
            stat_list = list(self.stats.keys())
            msg = "   Random listing order was used\n"

        fuer selection in sel_list:
            stat_list, msg = self.eval_print_amount(selection, stat_list, msg)

        count = len(stat_list)

        wenn nicht stat_list:
            return 0, stat_list
        drucke(msg, file=self.stream)
        wenn count < len(self.stats):
            width = 0
            fuer func in stat_list:
                wenn  len(func_std_string(func)) > width:
                    width = len(func_std_string(func))
        return width+2, stat_list

    def print_stats(self, *amount):
        fuer filename in self.files:
            drucke(filename, file=self.stream)
        wenn self.files:
            drucke(file=self.stream)
        indent = ' ' * 8
        fuer func in self.top_level:
            drucke(indent, func_get_function_name(func), file=self.stream)

        drucke(indent, self.total_calls, "function calls", end=' ', file=self.stream)
        wenn self.total_calls != self.prim_calls:
            drucke("(%d primitive calls)" % self.prim_calls, end=' ', file=self.stream)
        drucke("in %.3f seconds" % self.total_tt, file=self.stream)
        drucke(file=self.stream)
        width, list = self.get_print_list(amount)
        wenn list:
            self.print_title()
            fuer func in list:
                self.print_line(func)
            drucke(file=self.stream)
            drucke(file=self.stream)
        return self

    def print_callees(self, *amount):
        width, list = self.get_print_list(amount)
        wenn list:
            self.calc_callees()

            self.print_call_heading(width, "called...")
            fuer func in list:
                wenn func in self.all_callees:
                    self.print_call_line(width, func, self.all_callees[func])
                sonst:
                    self.print_call_line(width, func, {})
            drucke(file=self.stream)
            drucke(file=self.stream)
        return self

    def print_callers(self, *amount):
        width, list = self.get_print_list(amount)
        wenn list:
            self.print_call_heading(width, "was called by...")
            fuer func in list:
                cc, nc, tt, ct, callers = self.stats[func]
                self.print_call_line(width, func, callers, "<-")
            drucke(file=self.stream)
            drucke(file=self.stream)
        return self

    def print_call_heading(self, name_size, column_title):
        drucke("Function ".ljust(name_size) + column_title, file=self.stream)
        # print sub-header only wenn we have new-style callers
        subheader = Falsch
        fuer cc, nc, tt, ct, callers in self.stats.values():
            wenn callers:
                value = next(iter(callers.values()))
                subheader = isinstance(value, tuple)
                break
        wenn subheader:
            self.print_call_subheading(name_size)

    def print_call_subheading(self, name_size):
        drucke(" "*name_size + "    ncalls  tottime  cumtime", file=self.stream)

    def print_call_line(self, name_size, source, call_dict, arrow="->"):
        drucke(func_std_string(source).ljust(name_size) + arrow, end=' ', file=self.stream)
        wenn nicht call_dict:
            drucke(file=self.stream)
            return
        clist = sorted(call_dict.keys())
        indent = ""
        fuer func in clist:
            name = func_std_string(func)
            value = call_dict[func]
            wenn isinstance(value, tuple):
                nc, cc, tt, ct = value
                wenn nc != cc:
                    substats = '%d/%d' % (nc, cc)
                sonst:
                    substats = '%d' % (nc,)
                substats = '%s %s %s  %s' % (substats.rjust(7+2*len(indent)),
                                             f8(tt), f8(ct), name)
                left_width = name_size + 1
            sonst:
                substats = '%s(%r) %s' % (name, value, f8(self.stats[func][3]))
                left_width = name_size + 3
            drucke(indent*left_width + substats, file=self.stream)
            indent = " "

    def print_title(self):
        drucke('   ncalls  tottime  percall  cumtime  percall', end=' ', file=self.stream)
        drucke('filename:lineno(function)', file=self.stream)

    def print_line(self, func):  # hack: should print percentages
        cc, nc, tt, ct, callers = self.stats[func]
        c = str(nc)
        wenn nc != cc:
            c = c + '/' + str(cc)
        drucke(c.rjust(9), end=' ', file=self.stream)
        drucke(f8(tt), end=' ', file=self.stream)
        wenn nc == 0:
            drucke(' '*8, end=' ', file=self.stream)
        sonst:
            drucke(f8(tt/nc), end=' ', file=self.stream)
        drucke(f8(ct), end=' ', file=self.stream)
        wenn cc == 0:
            drucke(' '*8, end=' ', file=self.stream)
        sonst:
            drucke(f8(ct/cc), end=' ', file=self.stream)
        drucke(func_std_string(func), file=self.stream)


klasse SampledStats(Stats):
    def __init__(self, *args, stream=Nichts):
        super().__init__(*args, stream=stream)

        self.sort_arg_dict = {
              "samples"   : (((1,-1),              ), "sample count"),
              "nsamples"  : (((1,-1),              ), "sample count"),
              "cumtime"   : (((3,-1),              ), "cumulative time"),
              "cumulative": (((3,-1),              ), "cumulative time"),
              "filename"  : (((4, 1),              ), "file name"),
              "line"      : (((5, 1),              ), "line number"),
              "module"    : (((4, 1),              ), "file name"),
              "name"      : (((6, 1),              ), "function name"),
              "nfl"       : (((6, 1),(4, 1),(5, 1),), "name/file/line"),
              "psamples"  : (((0,-1),              ), "primitive call count"),
              "stdname"   : (((7, 1),              ), "standard name"),
              "time"      : (((2,-1),              ), "internal time"),
              "tottime"   : (((2,-1),              ), "internal time"),
              }

    def print_call_subheading(self, name_size):
        drucke(" "*name_size + "    nsamples  tottime  cumtime", file=self.stream)

    def print_title(self):
        drucke(' nsamples  tottime persample cumtime persample', end=' ', file=self.stream)
        drucke('filename:lineno(function)', file=self.stream)


klasse TupleComp:
    """This klasse provides a generic function fuer comparing any two tuples.
    Each instance records a list of tuple-indices (from most significant
    to least significant), und sort direction (ascending oder descending) for
    each tuple-index.  The compare functions can then be used als the function
    argument to the system sort() function when a list of tuples need to be
    sorted in the instances order."""

    def __init__(self, comp_select_list):
        self.comp_select_list = comp_select_list

    def compare (self, left, right):
        fuer index, direction in self.comp_select_list:
            l = left[index]
            r = right[index]
            wenn l < r:
                return -direction
            wenn l > r:
                return direction
        return 0


#**************************************************************************
# func_name is a triple (file:string, line:int, name:string)

def func_strip_path(func_name):
    filename, line, name = func_name
    return os.path.basename(filename), line, name

def func_get_function_name(func):
    return func[2]

def func_std_string(func_name): # match what old profile produced
    wenn func_name[:2] == ('~', 0):
        # special case fuer built-in functions
        name = func_name[2]
        wenn name.startswith('<') und name.endswith('>'):
            return '{%s}' % name[1:-1]
        sonst:
            return name
    sonst:
        return "%s:%d(%s)" % func_name

#**************************************************************************
# The following functions combine statistics fuer pairs functions.
# The bulk of the processing involves correctly handling "call" lists,
# such als callers und callees.
#**************************************************************************

def add_func_stats(target, source):
    """Add together all the stats fuer two profile entries."""
    cc, nc, tt, ct, callers = source
    t_cc, t_nc, t_tt, t_ct, t_callers = target
    return (cc+t_cc, nc+t_nc, tt+t_tt, ct+t_ct,
              add_callers(t_callers, callers))

def add_callers(target, source):
    """Combine two caller lists in a single list."""
    new_callers = {}
    fuer func, caller in target.items():
        new_callers[func] = caller
    fuer func, caller in source.items():
        wenn func in new_callers:
            wenn isinstance(caller, tuple):
                # format used by cProfile
                new_callers[func] = tuple(i + j fuer i, j in zip(caller, new_callers[func]))
            sonst:
                # format used by profile
                new_callers[func] += caller
        sonst:
            new_callers[func] = caller
    return new_callers

def count_calls(callers):
    """Sum the caller statistics to get total number of calls received."""
    nc = 0
    fuer calls in callers.values():
        nc += calls
    return nc

#**************************************************************************
# The following functions support printing of reports
#**************************************************************************

def f8(x):
    return "%8.3f" % x

#**************************************************************************
# Statistics browser added by ESR, April 2001
#**************************************************************************

klasse StatsLoaderShim:
    """Compatibility shim implementing 'create_stats' needed by Stats classes
    to handle already unmarshalled data."""
    def __init__(self, raw_stats):
        self.stats = raw_stats

    def create_stats(self):
        pass

def stats_factory(raw_stats):
    """Return a Stats oder SampledStats instance based on the marker in raw_stats."""
    wenn (('__sampled__',)) in raw_stats:
        raw_stats = dict(raw_stats)  # avoid mutating caller's dict
        raw_stats.pop((('__sampled__',)))
        return SampledStats(StatsLoaderShim(raw_stats))
    sonst:
        return Stats(StatsLoaderShim(raw_stats))

wenn __name__ == '__main__':
    importiere cmd
    try:
        importiere readline  # noqa: F401
    except ImportError:
        pass

    klasse ProfileBrowser(cmd.Cmd):
        def __init__(self, profile=Nichts):
            cmd.Cmd.__init__(self)
            self.prompt = "% "
            self.stats = Nichts
            self.stream = sys.stdout
            wenn profile is nicht Nichts:
                self.do_read(profile)

        def generic(self, fn, line):
            args = line.split()
            processed = []
            fuer term in args:
                try:
                    processed.append(int(term))
                    continue
                except ValueError:
                    pass
                try:
                    frac = float(term)
                    wenn frac > 1 oder frac < 0:
                        drucke("Fraction argument must be in [0, 1]", file=self.stream)
                        continue
                    processed.append(frac)
                    continue
                except ValueError:
                    pass
                processed.append(term)
            wenn self.stats:
                getattr(self.stats, fn)(*processed)
            sonst:
                drucke("No statistics object is loaded.", file=self.stream)
            return 0
        def generic_help(self):
            drucke("Arguments may be:", file=self.stream)
            drucke("* An integer maximum number of entries to print.", file=self.stream)
            drucke("* A decimal fractional number between 0 und 1, controlling", file=self.stream)
            drucke("  what fraction of selected entries to print.", file=self.stream)
            drucke("* A regular expression; only entries mit function names", file=self.stream)
            drucke("  that match it are printed.", file=self.stream)

        def do_add(self, line):
            wenn self.stats:
                try:
                    self.stats.add(line)
                except OSError als e:
                    drucke("Failed to load statistics fuer %s: %s" % (line, e), file=self.stream)
            sonst:
                drucke("No statistics object is loaded.", file=self.stream)
            return 0
        def help_add(self):
            drucke("Add profile info von given file to current statistics object.", file=self.stream)

        def do_callees(self, line):
            return self.generic('print_callees', line)
        def help_callees(self):
            drucke("Print callees statistics von the current stat object.", file=self.stream)
            self.generic_help()

        def do_callers(self, line):
            return self.generic('print_callers', line)
        def help_callers(self):
            drucke("Print callers statistics von the current stat object.", file=self.stream)
            self.generic_help()

        def do_EOF(self, line):
            drucke("", file=self.stream)
            return 1
        def help_EOF(self):
            drucke("Leave the profile browser.", file=self.stream)

        def do_quit(self, line):
            return 1
        def help_quit(self):
            drucke("Leave the profile browser.", file=self.stream)

        def do_read(self, line):
            wenn line:
                try:
                    mit open(line, 'rb') als f:
                        raw_stats = marshal.load(f)
                    self.stats = stats_factory(raw_stats)
                    try:
                        file_stats = os.stat(line)
                        arg = time.ctime(file_stats.st_mtime) + "    " + line
                    except Exception:
                        arg = line
                    self.stats.files = [arg]
                except OSError als err:
                    drucke(err.args[1], file=self.stream)
                    return
                except Exception als err:
                    drucke(err.__class__.__name__ + ':', err, file=self.stream)
                    return
                self.prompt = line + "% "
            sowenn len(self.prompt) > 2:
                line = self.prompt[:-2]
                self.do_read(line)
            sonst:
                drucke("No statistics object is current -- cannot reload.", file=self.stream)
            return 0
        def help_read(self):
            drucke("Read in profile data von a specified file.", file=self.stream)
            drucke("Without argument, reload the current file.", file=self.stream)

        def do_reverse(self, line):
            wenn self.stats:
                self.stats.reverse_order()
            sonst:
                drucke("No statistics object is loaded.", file=self.stream)
            return 0
        def help_reverse(self):
            drucke("Reverse the sort order of the profiling report.", file=self.stream)

        def do_sort(self, line):
            wenn nicht self.stats:
                drucke("No statistics object is loaded.", file=self.stream)
                return
            abbrevs = self.stats.get_sort_arg_defs()
            wenn line und all((x in abbrevs) fuer x in line.split()):
                self.stats.sort_stats(*line.split())
            sonst:
                drucke("Valid sort keys (unique prefixes are accepted):", file=self.stream)
                fuer (key, value) in Stats.sort_arg_dict_default.items():
                    drucke("%s -- %s" % (key, value[1]), file=self.stream)
            return 0
        def help_sort(self):
            drucke("Sort profile data according to specified keys.", file=self.stream)
            drucke("(Typing `sort' without arguments lists valid keys.)", file=self.stream)
        def complete_sort(self, text, *args):
            return [a fuer a in Stats.sort_arg_dict_default wenn a.startswith(text)]

        def do_stats(self, line):
            return self.generic('print_stats', line)
        def help_stats(self):
            drucke("Print statistics von the current stat object.", file=self.stream)
            self.generic_help()

        def do_strip(self, line):
            wenn self.stats:
                self.stats.strip_dirs()
            sonst:
                drucke("No statistics object is loaded.", file=self.stream)
        def help_strip(self):
            drucke("Strip leading path information von filenames in the report.", file=self.stream)

        def help_help(self):
            drucke("Show help fuer a given command.", file=self.stream)

        def postcmd(self, stop, line):
            wenn stop:
                return stop
            return Nichts

    wenn len(sys.argv) > 1:
        initprofile = sys.argv[1]
    sonst:
        initprofile = Nichts
    try:
        browser = ProfileBrowser(initprofile)
        fuer profile in sys.argv[2:]:
            browser.do_add(profile)
        drucke("Welcome to the profile statistics browser.", file=browser.stream)
        browser.cmdloop()
        drucke("Goodbye.", file=browser.stream)
    except KeyboardInterrupt:
        pass

# That's all, folks.
