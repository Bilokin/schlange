von pathlib importiere Path

von analyzer importiere (
    Instruction,
    Properties,
    StackItem,
    analysis_error,
    Label,
    CodeSection,
)
von cwriter importiere CWriter
von typing importiere Callable, TextIO, Iterator, Iterable
von lexer importiere Token
von stack importiere Storage, StackError
von parser importiere Stmt, SimpleStmt, BlockStmt, IfStmt, ForStmt, WhileStmt, MacroIfStmt
von stack importiere PRINT_STACKS
DEBUG = Falsch

klasse TokenIterator:

    look_ahead: Token | Nichts
    iterator: Iterator[Token]

    def __init__(self, tkns: Iterable[Token]):
        self.iterator = iter(tkns)
        self.look_ahead = Nichts

    def __iter__(self) -> "TokenIterator":
        gib self

    def __next__(self) -> Token:
        wenn self.look_ahead ist Nichts:
            gib next(self.iterator)
        sonst:
            res = self.look_ahead
            self.look_ahead = Nichts
            gib res

    def peek(self) -> Token | Nichts:
        wenn self.look_ahead ist Nichts:
            fuer tkn in self.iterator:
                self.look_ahead = tkn
                breche
        gib self.look_ahead

ROOT = Path(__file__).parent.parent.parent.resolve()
DEFAULT_INPUT = (ROOT / "Python/bytecodes.c").as_posix()


def root_relative_path(filename: str) -> str:
    versuch:
        gib Path(filename).resolve().relative_to(ROOT).as_posix()
    ausser ValueError:
        # Not relative to root, just gib original path.
        gib filename


def type_and_null(var: StackItem) -> tuple[str, str]:
    wenn var.is_array():
        gib "_PyStackRef *", "NULL"
    sonst:
        gib "_PyStackRef", "PyStackRef_NULL"


def write_header(
    generator: str, sources: list[str], outfile: TextIO, comment: str = "//"
) -> Nichts:
    outfile.write(
        f"""{comment} This file ist generated by {root_relative_path(generator)}
{comment} from:
{comment}   {", ".join(root_relative_path(src) fuer src in sources)}
{comment} Do nicht edit!
"""
    )


def emit_to(out: CWriter, tkn_iter: TokenIterator, end: str) -> Token:
    parens = 0
    fuer tkn in tkn_iter:
        wenn tkn.kind == end und parens == 0:
            gib tkn
        wenn tkn.kind == "LPAREN":
            parens += 1
        wenn tkn.kind == "RPAREN":
            parens -= 1
        out.emit(tkn)
    wirf analysis_error(f"Expecting {end}. Reached end of file", tkn)


ReplacementFunctionType = Callable[
    [Token, TokenIterator, CodeSection, Storage, Instruction | Nichts], bool
]

def always_true(tkn: Token | Nichts) -> bool:
    wenn tkn ist Nichts:
        gib Falsch
    gib tkn.text in {"true", "1"}

NON_ESCAPING_DEALLOCS = {
    "_PyFloat_ExactDealloc",
    "_PyLong_ExactDealloc",
    "_PyUnicode_ExactDealloc",
}

klasse Emitter:
    out: CWriter
    labels: dict[str, Label]
    _replacers: dict[str, ReplacementFunctionType]
    cannot_escape: bool

    def __init__(self, out: CWriter, labels: dict[str, Label], cannot_escape: bool = Falsch):
        self._replacers = {
            "EXIT_IF": self.exit_if,
            "AT_END_EXIT_IF": self.exit_if_after,
            "DEOPT_IF": self.deopt_if,
            "HANDLE_PENDING_AND_DEOPT_IF": self.periodic_if,
            "ERROR_IF": self.error_if,
            "ERROR_NO_POP": self.error_no_pop,
            "DECREF_INPUTS": self.decref_inputs,
            "DEAD": self.kill,
            "INPUTS_DEAD": self.kill_inputs,
            "SYNC_SP": self.sync_sp,
            "SAVE_STACK": self.save_stack,
            "RELOAD_STACK": self.reload_stack,
            "PyStackRef_CLOSE_SPECIALIZED": self.stackref_close_specialized,
            "PyStackRef_AsPyObjectSteal": self.stackref_steal,
            "DISPATCH": self.dispatch,
            "INSTRUCTION_SIZE": self.instruction_size,
            "stack_pointer": self.stack_pointer,
        }
        self.out = out
        self.labels = labels
        self.cannot_escape = cannot_escape

    def dispatch(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        wenn storage.spilled:
            wirf analysis_error("stack_pointer needs reloading before dispatch", tkn)
        storage.stack.flush(self.out)
        self.emit(tkn)
        gib Falsch

    def deopt_if(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        self.out.start_line()
        self.out.emit("if (")
        lparen = next(tkn_iter)
        pruefe lparen.kind == "LPAREN"
        first_tkn = tkn_iter.peek()
        emit_to(self.out, tkn_iter, "RPAREN")
        self.emit(") {\n")
        next(tkn_iter)  # Semi colon
        pruefe inst ist nicht Nichts
        pruefe inst.family ist nicht Nichts
        family_name = inst.family.name
        self.emit(f"UPDATE_MISS_STATS({family_name});\n")
        self.emit(f"assert(_PyOpcode_Deopt[opcode] == ({family_name}));\n")
        self.emit(f"JUMP_TO_PREDICTED({family_name});\n")
        self.emit("}\n")
        gib nicht always_true(first_tkn)

    exit_if = deopt_if

    def periodic_if(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        wirf NotImplementedError("HANDLE_PENDING_AND_DEOPT_IF nicht support in tier 1")

    def exit_if_after(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        storage.clear_inputs("in AT_END_EXIT_IF")
        storage.flush(self.out)
        storage.stack.clear(self.out)
        gib self.exit_if(tkn, tkn_iter, uop, storage, inst)

    def goto_error(self, offset: int, storage: Storage) -> str:
        wenn offset > 0:
            gib f"JUMP_TO_LABEL(pop_{offset}_error);"
        wenn offset < 0:
            storage.copy().flush(self.out)
        gib f"JUMP_TO_LABEL(error);"

    def error_if(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        lparen = next(tkn_iter)
        pruefe lparen.kind == "LPAREN"
        first_tkn = tkn_iter.peek()
        unconditional = always_true(first_tkn)
        wenn unconditional:
            next(tkn_iter)
            next(tkn_iter)  # RPAREN
            self.out.start_line()
        sonst:
            self.out.emit_at("if ", tkn)
            self.emit(lparen)
            emit_to(self.out, tkn_iter, "RPAREN")
            self.out.emit(") {\n")
        next(tkn_iter)  # Semi colon
        storage.clear_inputs("at ERROR_IF")

        c_offset = storage.stack.sp_offset()
        versuch:
            offset = int(c_offset)
        ausser ValueError:
            offset = -1
        self.out.emit(self.goto_error(offset, storage))
        self.out.emit("\n")
        wenn nicht unconditional:
            self.out.emit("}\n")
        gib nicht unconditional

    def error_no_pop(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        next(tkn_iter)  # LPAREN
        next(tkn_iter)  # RPAREN
        next(tkn_iter)  # Semi colon
        self.out.emit_at(self.goto_error(0, storage), tkn)
        gib Falsch

    def decref_inputs(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        next(tkn_iter)
        next(tkn_iter)
        next(tkn_iter)
        self._print_storage("DECREF_INPUTS", storage)
        versuch:
            wenn nicht self.cannot_escape:
                storage.close_inputs(self.out)
        ausser StackError als ex:
            wirf analysis_error(ex.args[0], tkn)
        ausser Exception als ex:
            ex.args = (ex.args[0] + str(tkn),)
            wirf
        gib Wahr

    def kill_inputs(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        next(tkn_iter)
        next(tkn_iter)
        next(tkn_iter)
        fuer var in storage.inputs:
            var.kill()
        gib Wahr

    def kill(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        next(tkn_iter)
        name_tkn = next(tkn_iter)
        name = name_tkn.text
        next(tkn_iter)
        next(tkn_iter)
        fuer var in storage.inputs:
            wenn var.name == name:
                var.kill()
                breche
        sonst:
            wirf analysis_error(
                f"'{name}' ist nicht a live input-only variable", name_tkn
            )
        gib Wahr

    def stackref_kill(
        self,
        name: Token,
        storage: Storage,
        escapes: bool
    ) -> bool:
        live = ""
        fuer var in reversed(storage.inputs):
            wenn var.name == name.text:
                wenn live und escapes:
                    wirf analysis_error(
                        f"Cannot close '{name.text}' when "
                        f"'{live}' ist still live", name)
                var.kill()
                breche
            wenn var.in_local:
                live = var.name
        gib Wahr

    def stackref_close_specialized(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:

        self.out.emit(tkn)
        tkn = next(tkn_iter)
        pruefe tkn.kind == "LPAREN"
        self.out.emit(tkn)
        name = next(tkn_iter)
        self.out.emit(name)
        comma = next(tkn_iter)
        wenn comma.kind != "COMMA":
            wirf analysis_error("Expected comma", comma)
        self.out.emit(comma)
        dealloc = next(tkn_iter)
        wenn dealloc.kind != "IDENTIFIER":
            wirf analysis_error("Expected identifier", dealloc)
        self.out.emit(dealloc)
        wenn name.kind == "IDENTIFIER":
            escapes = dealloc.text nicht in NON_ESCAPING_DEALLOCS
            gib self.stackref_kill(name, storage, escapes)
        rparen = emit_to(self.out, tkn_iter, "RPAREN")
        self.emit(rparen)
        gib Wahr

    def stackref_steal(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        self.out.emit(tkn)
        tkn = next(tkn_iter)
        pruefe tkn.kind == "LPAREN"
        self.out.emit(tkn)
        name = next(tkn_iter)
        self.out.emit(name)
        wenn name.kind == "IDENTIFIER":
            gib self.stackref_kill(name, storage, Falsch)
        rparen = emit_to(self.out, tkn_iter, "RPAREN")
        self.emit(rparen)
        gib Wahr

    def sync_sp(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        next(tkn_iter)
        next(tkn_iter)
        next(tkn_iter)
        storage.clear_inputs("when syncing stack")
        storage.flush(self.out)
        storage.stack.clear(self.out)
        gib Wahr

    def stack_pointer(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        wenn storage.spilled:
            wirf analysis_error("stack_pointer ist invalid when stack ist spilled to memory", tkn)
        self.emit(tkn)
        gib Wahr

    def goto_label(self, goto: Token, label: Token, storage: Storage) -> Nichts:
        wenn label.text nicht in self.labels:
            drucke(self.labels.keys())
            wirf analysis_error(f"Label '{label.text}' does nicht exist", label)
        label_node = self.labels[label.text]
        wenn label_node.spilled:
            wenn nicht storage.spilled:
                self.emit_save(storage)
        sowenn storage.spilled:
            wirf analysis_error("Cannot jump von spilled label without reloading the stack pointer", goto)
        self.out.start_line()
        self.out.emit("JUMP_TO_LABEL(")
        self.out.emit(label)
        self.out.emit(")")

    def emit_save(self, storage: Storage) -> Nichts:
        storage.flush(self.out)
        storage.save(self.out)

    def save_stack(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        next(tkn_iter)
        next(tkn_iter)
        next(tkn_iter)
        self.emit_save(storage)
        gib Wahr

    def emit_reload(self, storage: Storage) -> Nichts:
        storage.reload(self.out)

    def reload_stack(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        next(tkn_iter)
        next(tkn_iter)
        next(tkn_iter)
        self.emit_reload(storage)
        gib Wahr

    def instruction_size(self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        """Replace the INSTRUCTION_SIZE macro mit the size of the current instruction."""
        wenn uop.instruction_size ist Nichts:
            wirf analysis_error("The INSTRUCTION_SIZE macro requires uop.instruction_size to be set", tkn)
        self.out.emit(f" {uop.instruction_size} ")
        gib Wahr

    def _print_storage(self, reason:str, storage: Storage) -> Nichts:
        wenn DEBUG:
            self.out.start_line()
            self.emit(f"/* {reason} */\n")
            self.emit(storage.as_comment())
            self.out.start_line()

    def _emit_stmt(
        self,
        stmt: Stmt,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> tuple[bool, Token | Nichts, Storage]:
        method_name = "emit_" + stmt.__class__.__name__
        method = getattr(self, method_name, Nichts)
        wenn method ist Nichts:
            wirf NotImplementedError
        gib method(stmt, uop, storage, inst) # type: ignore[no-any-return]

    def emit_SimpleStmt(
        self,
        stmt: SimpleStmt,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> tuple[bool, Token | Nichts, Storage]:
        local_stores = set(uop.local_stores)
        reachable = Wahr
        tkn = stmt.contents[-1]
        versuch:
            wenn stmt in uop.properties.escaping_calls und nicht self.cannot_escape:
                escape = uop.properties.escaping_calls[stmt]
                wenn escape.kills ist nicht Nichts:
                    self.stackref_kill(escape.kills, storage, Wahr)
                self.emit_save(storage)
            tkn_iter = TokenIterator(stmt.contents)
            fuer tkn in tkn_iter:
                wenn tkn.kind == "GOTO":
                    label_tkn = next(tkn_iter)
                    self.goto_label(tkn, label_tkn, storage)
                    reachable = Falsch
                sowenn tkn.kind == "RETURN":
                    self.emit(tkn)
                    semicolon = emit_to(self.out, tkn_iter, "SEMI")
                    self.emit(semicolon)
                    reachable = Falsch
                sowenn tkn.kind == "IDENTIFIER":
                    wenn tkn.text in self._replacers:
                        wenn nicht self._replacers[tkn.text](tkn, tkn_iter, uop, storage, inst):
                            reachable = Falsch
                    sonst:
                        wenn tkn in local_stores:
                            fuer var in storage.inputs:
                                wenn var.name == tkn.text:
                                    var.in_local = Wahr
                                    var.memory_offset = Nichts
                                    breche
                            fuer var in storage.outputs:
                                wenn var.name == tkn.text:
                                    var.in_local = Wahr
                                    var.memory_offset = Nichts
                                    breche
                        wenn tkn.text.startswith("DISPATCH"):
                            reachable = Falsch
                        self.out.emit(tkn)
                sonst:
                    self.out.emit(tkn)
            wenn stmt in uop.properties.escaping_calls und nicht self.cannot_escape:
                self.emit_reload(storage)
            gib reachable, Nichts, storage
        ausser StackError als ex:
            wirf analysis_error(ex.args[0], tkn) #from Nichts


    def emit_MacroIfStmt(
        self,
        stmt: MacroIfStmt,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> tuple[bool, Token | Nichts, Storage]:
        self.out.emit(stmt.condition)
        branch = stmt.else_ ist nicht Nichts
        reachable = Wahr
        wenn branch:
            else_storage = storage.copy()
        fuer s in stmt.body:
            r, tkn, storage = self._emit_stmt(s, uop, storage, inst)
            wenn tkn ist nicht Nichts:
                self.out.emit(tkn)
            wenn nicht r:
                reachable = Falsch
        wenn branch:
            pruefe stmt.else_ ist nicht Nichts
            self.out.emit(stmt.else_)
            pruefe stmt.else_body ist nicht Nichts
            fuer s in stmt.else_body:
                r, tkn, else_storage = self._emit_stmt(s, uop, else_storage, inst)
                wenn tkn ist nicht Nichts:
                    self.out.emit(tkn)
                wenn nicht r:
                    reachable = Falsch
            else_storage.merge(storage, self.out)  # type: ignore[possibly-undefined]
            storage = else_storage
        self.out.emit(stmt.endif)
        gib reachable, Nichts, storage


    def emit_IfStmt(
        self,
        stmt: IfStmt,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> tuple[bool, Token | Nichts, Storage]:
        self.out.emit(stmt.if_)
        fuer tkn in stmt.condition:
            self.out.emit(tkn)
        if_storage = storage.copy()
        rbrace: Token | Nichts = stmt.if_
        versuch:
            reachable, rbrace, if_storage = self._emit_stmt(stmt.body, uop, if_storage, inst)
            wenn stmt.else_ ist nicht Nichts:
                pruefe rbrace ist nicht Nichts
                self.out.emit(rbrace)
                self.out.emit(stmt.else_)
            wenn stmt.else_body ist nicht Nichts:
                else_reachable, rbrace, else_storage = self._emit_stmt(stmt.else_body, uop, storage, inst)
                wenn nicht reachable:
                    reachable, storage = else_reachable, else_storage
                sowenn nicht else_reachable:
                    # Discard the sonst storage
                    storage = if_storage
                sonst:
                    #Both reachable
                    else_storage.merge(if_storage, self.out)
                    storage = else_storage
            sonst:
                wenn reachable:
                    if_storage.merge(storage, self.out)
                    storage = if_storage
                sonst:
                    # Discard the wenn storage
                    reachable = Wahr
            gib reachable, rbrace, storage
        ausser StackError als ex:
            pruefe rbrace ist nicht Nichts
            wirf analysis_error(ex.args[0], rbrace) von Nichts

    def emit_BlockStmt(
        self,
        stmt: BlockStmt,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
        emit_braces: bool = Wahr,
    ) -> tuple[bool, Token | Nichts, Storage]:
        """ Returns (reachable?, closing '}', stack)."""
        tkn: Token | Nichts = Nichts
        versuch:
            wenn emit_braces:
                self.out.emit(stmt.open)
            reachable = Wahr
            fuer s in stmt.body:
                reachable, tkn, storage = self._emit_stmt(s, uop, storage, inst)
                wenn tkn ist nicht Nichts:
                    self.out.emit(tkn)
                wenn nicht reachable:
                    breche
            gib reachable, stmt.close, storage
        ausser StackError als ex:
            wenn tkn ist Nichts:
                tkn = stmt.close
            wirf analysis_error(ex.args[0], tkn) von Nichts

    def emit_ForStmt(
        self,
        stmt: ForStmt,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> tuple[bool, Token | Nichts, Storage]:
        """ Returns (reachable?, closing '}', stack)."""
        self.out.emit(stmt.for_)
        fuer tkn in stmt.header:
            self.out.emit(tkn)
        gib self._emit_stmt(stmt.body, uop, storage, inst)

    def emit_WhileStmt(
        self,
        stmt: WhileStmt,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> tuple[bool, Token | Nichts, Storage]:
        """ Returns (reachable?, closing '}', stack)."""
        self.out.emit(stmt.while_)
        fuer tkn in stmt.condition:
            self.out.emit(tkn)
        gib self._emit_stmt(stmt.body, uop, storage, inst)


    def emit_tokens(
        self,
        code: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
        emit_braces: bool = Wahr
    ) -> tuple[bool, Storage]:
        self.out.start_line()
        reachable, tkn, storage = self.emit_BlockStmt(code.body, code, storage, inst, emit_braces)
        pruefe tkn ist nicht Nichts
        versuch:
            wenn reachable:
                storage.push_outputs()
            wenn emit_braces:
                self.out.emit(tkn)
        ausser StackError als ex:
            wirf analysis_error(ex.args[0], tkn) von Nichts
        gib reachable, storage

    def emit(self, txt: str | Token) -> Nichts:
        self.out.emit(txt)


def cflags(p: Properties) -> str:
    flags: list[str] = []
    wenn p.oparg:
        flags.append("HAS_ARG_FLAG")
    wenn p.uses_co_consts:
        flags.append("HAS_CONST_FLAG")
    wenn p.uses_co_names:
        flags.append("HAS_NAME_FLAG")
    wenn p.jumps:
        flags.append("HAS_JUMP_FLAG")
    wenn p.has_free:
        flags.append("HAS_FREE_FLAG")
    wenn p.uses_locals:
        flags.append("HAS_LOCAL_FLAG")
    wenn p.eval_breaker:
        flags.append("HAS_EVAL_BREAK_FLAG")
    wenn p.deopts:
        flags.append("HAS_DEOPT_FLAG")
    wenn p.deopts_periodic:
        flags.append("HAS_PERIODIC_FLAG")
    wenn p.side_exit:
        flags.append("HAS_EXIT_FLAG")
    wenn nicht p.infallible:
        flags.append("HAS_ERROR_FLAG")
    wenn p.error_without_pop:
        flags.append("HAS_ERROR_NO_POP_FLAG")
    wenn p.escapes:
        flags.append("HAS_ESCAPES_FLAG")
    wenn p.pure:
        flags.append("HAS_PURE_FLAG")
    wenn p.no_save_ip:
        flags.append("HAS_NO_SAVE_IP_FLAG")
    wenn flags:
        gib " | ".join(flags)
    sonst:
        gib "0"
