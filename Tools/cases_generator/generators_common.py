from pathlib import Path

from analyzer import (
    Instruction,
    Properties,
    StackItem,
    analysis_error,
    Label,
    CodeSection,
)
from cwriter import CWriter
from typing import Callable, TextIO, Iterator, Iterable
from lexer import Token
from stack import Storage, StackError
from parser import Stmt, SimpleStmt, BlockStmt, IfStmt, ForStmt, WhileStmt, MacroIfStmt
from stack import PRINT_STACKS
DEBUG = Falsch

klasse TokenIterator:

    look_ahead: Token | Nichts
    iterator: Iterator[Token]

    def __init__(self, tkns: Iterable[Token]):
        self.iterator = iter(tkns)
        self.look_ahead = Nichts

    def __iter__(self) -> "TokenIterator":
        return self

    def __next__(self) -> Token:
        wenn self.look_ahead is Nichts:
            return next(self.iterator)
        sonst:
            res = self.look_ahead
            self.look_ahead = Nichts
            return res

    def peek(self) -> Token | Nichts:
        wenn self.look_ahead is Nichts:
            fuer tkn in self.iterator:
                self.look_ahead = tkn
                break
        return self.look_ahead

ROOT = Path(__file__).parent.parent.parent.resolve()
DEFAULT_INPUT = (ROOT / "Python/bytecodes.c").as_posix()


def root_relative_path(filename: str) -> str:
    try:
        return Path(filename).resolve().relative_to(ROOT).as_posix()
    except ValueError:
        # Not relative to root, just return original path.
        return filename


def type_and_null(var: StackItem) -> tuple[str, str]:
    wenn var.is_array():
        return "_PyStackRef *", "NULL"
    sonst:
        return "_PyStackRef", "PyStackRef_NULL"


def write_header(
    generator: str, sources: list[str], outfile: TextIO, comment: str = "//"
) -> Nichts:
    outfile.write(
        f"""{comment} This file is generated by {root_relative_path(generator)}
{comment} from:
{comment}   {", ".join(root_relative_path(src) fuer src in sources)}
{comment} Do not edit!
"""
    )


def emit_to(out: CWriter, tkn_iter: TokenIterator, end: str) -> Token:
    parens = 0
    fuer tkn in tkn_iter:
        wenn tkn.kind == end and parens == 0:
            return tkn
        wenn tkn.kind == "LPAREN":
            parens += 1
        wenn tkn.kind == "RPAREN":
            parens -= 1
        out.emit(tkn)
    raise analysis_error(f"Expecting {end}. Reached end of file", tkn)


ReplacementFunctionType = Callable[
    [Token, TokenIterator, CodeSection, Storage, Instruction | Nichts], bool
]

def always_true(tkn: Token | Nichts) -> bool:
    wenn tkn is Nichts:
        return Falsch
    return tkn.text in {"true", "1"}

NON_ESCAPING_DEALLOCS = {
    "_PyFloat_ExactDealloc",
    "_PyLong_ExactDealloc",
    "_PyUnicode_ExactDealloc",
}

klasse Emitter:
    out: CWriter
    labels: dict[str, Label]
    _replacers: dict[str, ReplacementFunctionType]
    cannot_escape: bool

    def __init__(self, out: CWriter, labels: dict[str, Label], cannot_escape: bool = Falsch):
        self._replacers = {
            "EXIT_IF": self.exit_if,
            "AT_END_EXIT_IF": self.exit_if_after,
            "DEOPT_IF": self.deopt_if,
            "HANDLE_PENDING_AND_DEOPT_IF": self.periodic_if,
            "ERROR_IF": self.error_if,
            "ERROR_NO_POP": self.error_no_pop,
            "DECREF_INPUTS": self.decref_inputs,
            "DEAD": self.kill,
            "INPUTS_DEAD": self.kill_inputs,
            "SYNC_SP": self.sync_sp,
            "SAVE_STACK": self.save_stack,
            "RELOAD_STACK": self.reload_stack,
            "PyStackRef_CLOSE_SPECIALIZED": self.stackref_close_specialized,
            "PyStackRef_AsPyObjectSteal": self.stackref_steal,
            "DISPATCH": self.dispatch,
            "INSTRUCTION_SIZE": self.instruction_size,
            "stack_pointer": self.stack_pointer,
        }
        self.out = out
        self.labels = labels
        self.cannot_escape = cannot_escape

    def dispatch(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        wenn storage.spilled:
            raise analysis_error("stack_pointer needs reloading before dispatch", tkn)
        storage.stack.flush(self.out)
        self.emit(tkn)
        return Falsch

    def deopt_if(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        self.out.start_line()
        self.out.emit("if (")
        lparen = next(tkn_iter)
        assert lparen.kind == "LPAREN"
        first_tkn = tkn_iter.peek()
        emit_to(self.out, tkn_iter, "RPAREN")
        self.emit(") {\n")
        next(tkn_iter)  # Semi colon
        assert inst is not Nichts
        assert inst.family is not Nichts
        family_name = inst.family.name
        self.emit(f"UPDATE_MISS_STATS({family_name});\n")
        self.emit(f"assert(_PyOpcode_Deopt[opcode] == ({family_name}));\n")
        self.emit(f"JUMP_TO_PREDICTED({family_name});\n")
        self.emit("}\n")
        return not always_true(first_tkn)

    exit_if = deopt_if

    def periodic_if(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        raise NotImplementedError("HANDLE_PENDING_AND_DEOPT_IF not support in tier 1")

    def exit_if_after(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        storage.clear_inputs("in AT_END_EXIT_IF")
        storage.flush(self.out)
        storage.stack.clear(self.out)
        return self.exit_if(tkn, tkn_iter, uop, storage, inst)

    def goto_error(self, offset: int, storage: Storage) -> str:
        wenn offset > 0:
            return f"JUMP_TO_LABEL(pop_{offset}_error);"
        wenn offset < 0:
            storage.copy().flush(self.out)
        return f"JUMP_TO_LABEL(error);"

    def error_if(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        lparen = next(tkn_iter)
        assert lparen.kind == "LPAREN"
        first_tkn = tkn_iter.peek()
        unconditional = always_true(first_tkn)
        wenn unconditional:
            next(tkn_iter)
            next(tkn_iter)  # RPAREN
            self.out.start_line()
        sonst:
            self.out.emit_at("if ", tkn)
            self.emit(lparen)
            emit_to(self.out, tkn_iter, "RPAREN")
            self.out.emit(") {\n")
        next(tkn_iter)  # Semi colon
        storage.clear_inputs("at ERROR_IF")

        c_offset = storage.stack.sp_offset()
        try:
            offset = int(c_offset)
        except ValueError:
            offset = -1
        self.out.emit(self.goto_error(offset, storage))
        self.out.emit("\n")
        wenn not unconditional:
            self.out.emit("}\n")
        return not unconditional

    def error_no_pop(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        next(tkn_iter)  # LPAREN
        next(tkn_iter)  # RPAREN
        next(tkn_iter)  # Semi colon
        self.out.emit_at(self.goto_error(0, storage), tkn)
        return Falsch

    def decref_inputs(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        next(tkn_iter)
        next(tkn_iter)
        next(tkn_iter)
        self._print_storage("DECREF_INPUTS", storage)
        try:
            wenn not self.cannot_escape:
                storage.close_inputs(self.out)
        except StackError as ex:
            raise analysis_error(ex.args[0], tkn)
        except Exception as ex:
            ex.args = (ex.args[0] + str(tkn),)
            raise
        return Wahr

    def kill_inputs(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        next(tkn_iter)
        next(tkn_iter)
        next(tkn_iter)
        fuer var in storage.inputs:
            var.kill()
        return Wahr

    def kill(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        next(tkn_iter)
        name_tkn = next(tkn_iter)
        name = name_tkn.text
        next(tkn_iter)
        next(tkn_iter)
        fuer var in storage.inputs:
            wenn var.name == name:
                var.kill()
                break
        sonst:
            raise analysis_error(
                f"'{name}' is not a live input-only variable", name_tkn
            )
        return Wahr

    def stackref_kill(
        self,
        name: Token,
        storage: Storage,
        escapes: bool
    ) -> bool:
        live = ""
        fuer var in reversed(storage.inputs):
            wenn var.name == name.text:
                wenn live and escapes:
                    raise analysis_error(
                        f"Cannot close '{name.text}' when "
                        f"'{live}' is still live", name)
                var.kill()
                break
            wenn var.in_local:
                live = var.name
        return Wahr

    def stackref_close_specialized(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:

        self.out.emit(tkn)
        tkn = next(tkn_iter)
        assert tkn.kind == "LPAREN"
        self.out.emit(tkn)
        name = next(tkn_iter)
        self.out.emit(name)
        comma = next(tkn_iter)
        wenn comma.kind != "COMMA":
            raise analysis_error("Expected comma", comma)
        self.out.emit(comma)
        dealloc = next(tkn_iter)
        wenn dealloc.kind != "IDENTIFIER":
            raise analysis_error("Expected identifier", dealloc)
        self.out.emit(dealloc)
        wenn name.kind == "IDENTIFIER":
            escapes = dealloc.text not in NON_ESCAPING_DEALLOCS
            return self.stackref_kill(name, storage, escapes)
        rparen = emit_to(self.out, tkn_iter, "RPAREN")
        self.emit(rparen)
        return Wahr

    def stackref_steal(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        self.out.emit(tkn)
        tkn = next(tkn_iter)
        assert tkn.kind == "LPAREN"
        self.out.emit(tkn)
        name = next(tkn_iter)
        self.out.emit(name)
        wenn name.kind == "IDENTIFIER":
            return self.stackref_kill(name, storage, Falsch)
        rparen = emit_to(self.out, tkn_iter, "RPAREN")
        self.emit(rparen)
        return Wahr

    def sync_sp(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        next(tkn_iter)
        next(tkn_iter)
        next(tkn_iter)
        storage.clear_inputs("when syncing stack")
        storage.flush(self.out)
        storage.stack.clear(self.out)
        return Wahr

    def stack_pointer(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        wenn storage.spilled:
            raise analysis_error("stack_pointer is invalid when stack is spilled to memory", tkn)
        self.emit(tkn)
        return Wahr

    def goto_label(self, goto: Token, label: Token, storage: Storage) -> Nichts:
        wenn label.text not in self.labels:
            drucke(self.labels.keys())
            raise analysis_error(f"Label '{label.text}' does not exist", label)
        label_node = self.labels[label.text]
        wenn label_node.spilled:
            wenn not storage.spilled:
                self.emit_save(storage)
        sowenn storage.spilled:
            raise analysis_error("Cannot jump from spilled label without reloading the stack pointer", goto)
        self.out.start_line()
        self.out.emit("JUMP_TO_LABEL(")
        self.out.emit(label)
        self.out.emit(")")

    def emit_save(self, storage: Storage) -> Nichts:
        storage.flush(self.out)
        storage.save(self.out)

    def save_stack(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        next(tkn_iter)
        next(tkn_iter)
        next(tkn_iter)
        self.emit_save(storage)
        return Wahr

    def emit_reload(self, storage: Storage) -> Nichts:
        storage.reload(self.out)

    def reload_stack(
        self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        next(tkn_iter)
        next(tkn_iter)
        next(tkn_iter)
        self.emit_reload(storage)
        return Wahr

    def instruction_size(self,
        tkn: Token,
        tkn_iter: TokenIterator,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> bool:
        """Replace the INSTRUCTION_SIZE macro with the size of the current instruction."""
        wenn uop.instruction_size is Nichts:
            raise analysis_error("The INSTRUCTION_SIZE macro requires uop.instruction_size to be set", tkn)
        self.out.emit(f" {uop.instruction_size} ")
        return Wahr

    def _print_storage(self, reason:str, storage: Storage) -> Nichts:
        wenn DEBUG:
            self.out.start_line()
            self.emit(f"/* {reason} */\n")
            self.emit(storage.as_comment())
            self.out.start_line()

    def _emit_stmt(
        self,
        stmt: Stmt,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> tuple[bool, Token | Nichts, Storage]:
        method_name = "emit_" + stmt.__class__.__name__
        method = getattr(self, method_name, Nichts)
        wenn method is Nichts:
            raise NotImplementedError
        return method(stmt, uop, storage, inst) # type: ignore[no-any-return]

    def emit_SimpleStmt(
        self,
        stmt: SimpleStmt,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> tuple[bool, Token | Nichts, Storage]:
        local_stores = set(uop.local_stores)
        reachable = Wahr
        tkn = stmt.contents[-1]
        try:
            wenn stmt in uop.properties.escaping_calls and not self.cannot_escape:
                escape = uop.properties.escaping_calls[stmt]
                wenn escape.kills is not Nichts:
                    self.stackref_kill(escape.kills, storage, Wahr)
                self.emit_save(storage)
            tkn_iter = TokenIterator(stmt.contents)
            fuer tkn in tkn_iter:
                wenn tkn.kind == "GOTO":
                    label_tkn = next(tkn_iter)
                    self.goto_label(tkn, label_tkn, storage)
                    reachable = Falsch
                sowenn tkn.kind == "RETURN":
                    self.emit(tkn)
                    semicolon = emit_to(self.out, tkn_iter, "SEMI")
                    self.emit(semicolon)
                    reachable = Falsch
                sowenn tkn.kind == "IDENTIFIER":
                    wenn tkn.text in self._replacers:
                        wenn not self._replacers[tkn.text](tkn, tkn_iter, uop, storage, inst):
                            reachable = Falsch
                    sonst:
                        wenn tkn in local_stores:
                            fuer var in storage.inputs:
                                wenn var.name == tkn.text:
                                    var.in_local = Wahr
                                    var.memory_offset = Nichts
                                    break
                            fuer var in storage.outputs:
                                wenn var.name == tkn.text:
                                    var.in_local = Wahr
                                    var.memory_offset = Nichts
                                    break
                        wenn tkn.text.startswith("DISPATCH"):
                            reachable = Falsch
                        self.out.emit(tkn)
                sonst:
                    self.out.emit(tkn)
            wenn stmt in uop.properties.escaping_calls and not self.cannot_escape:
                self.emit_reload(storage)
            return reachable, Nichts, storage
        except StackError as ex:
            raise analysis_error(ex.args[0], tkn) #from Nichts


    def emit_MacroIfStmt(
        self,
        stmt: MacroIfStmt,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> tuple[bool, Token | Nichts, Storage]:
        self.out.emit(stmt.condition)
        branch = stmt.else_ is not Nichts
        reachable = Wahr
        wenn branch:
            else_storage = storage.copy()
        fuer s in stmt.body:
            r, tkn, storage = self._emit_stmt(s, uop, storage, inst)
            wenn tkn is not Nichts:
                self.out.emit(tkn)
            wenn not r:
                reachable = Falsch
        wenn branch:
            assert stmt.else_ is not Nichts
            self.out.emit(stmt.else_)
            assert stmt.else_body is not Nichts
            fuer s in stmt.else_body:
                r, tkn, else_storage = self._emit_stmt(s, uop, else_storage, inst)
                wenn tkn is not Nichts:
                    self.out.emit(tkn)
                wenn not r:
                    reachable = Falsch
            else_storage.merge(storage, self.out)  # type: ignore[possibly-undefined]
            storage = else_storage
        self.out.emit(stmt.endif)
        return reachable, Nichts, storage


    def emit_IfStmt(
        self,
        stmt: IfStmt,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> tuple[bool, Token | Nichts, Storage]:
        self.out.emit(stmt.if_)
        fuer tkn in stmt.condition:
            self.out.emit(tkn)
        if_storage = storage.copy()
        rbrace: Token | Nichts = stmt.if_
        try:
            reachable, rbrace, if_storage = self._emit_stmt(stmt.body, uop, if_storage, inst)
            wenn stmt.else_ is not Nichts:
                assert rbrace is not Nichts
                self.out.emit(rbrace)
                self.out.emit(stmt.else_)
            wenn stmt.else_body is not Nichts:
                else_reachable, rbrace, else_storage = self._emit_stmt(stmt.else_body, uop, storage, inst)
                wenn not reachable:
                    reachable, storage = else_reachable, else_storage
                sowenn not else_reachable:
                    # Discard the sonst storage
                    storage = if_storage
                sonst:
                    #Both reachable
                    else_storage.merge(if_storage, self.out)
                    storage = else_storage
            sonst:
                wenn reachable:
                    if_storage.merge(storage, self.out)
                    storage = if_storage
                sonst:
                    # Discard the wenn storage
                    reachable = Wahr
            return reachable, rbrace, storage
        except StackError as ex:
            assert rbrace is not Nichts
            raise analysis_error(ex.args[0], rbrace) from Nichts

    def emit_BlockStmt(
        self,
        stmt: BlockStmt,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
        emit_braces: bool = Wahr,
    ) -> tuple[bool, Token | Nichts, Storage]:
        """ Returns (reachable?, closing '}', stack)."""
        tkn: Token | Nichts = Nichts
        try:
            wenn emit_braces:
                self.out.emit(stmt.open)
            reachable = Wahr
            fuer s in stmt.body:
                reachable, tkn, storage = self._emit_stmt(s, uop, storage, inst)
                wenn tkn is not Nichts:
                    self.out.emit(tkn)
                wenn not reachable:
                    break
            return reachable, stmt.close, storage
        except StackError as ex:
            wenn tkn is Nichts:
                tkn = stmt.close
            raise analysis_error(ex.args[0], tkn) from Nichts

    def emit_ForStmt(
        self,
        stmt: ForStmt,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> tuple[bool, Token | Nichts, Storage]:
        """ Returns (reachable?, closing '}', stack)."""
        self.out.emit(stmt.for_)
        fuer tkn in stmt.header:
            self.out.emit(tkn)
        return self._emit_stmt(stmt.body, uop, storage, inst)

    def emit_WhileStmt(
        self,
        stmt: WhileStmt,
        uop: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
    ) -> tuple[bool, Token | Nichts, Storage]:
        """ Returns (reachable?, closing '}', stack)."""
        self.out.emit(stmt.while_)
        fuer tkn in stmt.condition:
            self.out.emit(tkn)
        return self._emit_stmt(stmt.body, uop, storage, inst)


    def emit_tokens(
        self,
        code: CodeSection,
        storage: Storage,
        inst: Instruction | Nichts,
        emit_braces: bool = Wahr
    ) -> tuple[bool, Storage]:
        self.out.start_line()
        reachable, tkn, storage = self.emit_BlockStmt(code.body, code, storage, inst, emit_braces)
        assert tkn is not Nichts
        try:
            wenn reachable:
                storage.push_outputs()
            wenn emit_braces:
                self.out.emit(tkn)
        except StackError as ex:
            raise analysis_error(ex.args[0], tkn) from Nichts
        return reachable, storage

    def emit(self, txt: str | Token) -> Nichts:
        self.out.emit(txt)


def cflags(p: Properties) -> str:
    flags: list[str] = []
    wenn p.oparg:
        flags.append("HAS_ARG_FLAG")
    wenn p.uses_co_consts:
        flags.append("HAS_CONST_FLAG")
    wenn p.uses_co_names:
        flags.append("HAS_NAME_FLAG")
    wenn p.jumps:
        flags.append("HAS_JUMP_FLAG")
    wenn p.has_free:
        flags.append("HAS_FREE_FLAG")
    wenn p.uses_locals:
        flags.append("HAS_LOCAL_FLAG")
    wenn p.eval_breaker:
        flags.append("HAS_EVAL_BREAK_FLAG")
    wenn p.deopts:
        flags.append("HAS_DEOPT_FLAG")
    wenn p.deopts_periodic:
        flags.append("HAS_PERIODIC_FLAG")
    wenn p.side_exit:
        flags.append("HAS_EXIT_FLAG")
    wenn not p.infallible:
        flags.append("HAS_ERROR_FLAG")
    wenn p.error_without_pop:
        flags.append("HAS_ERROR_NO_POP_FLAG")
    wenn p.escapes:
        flags.append("HAS_ESCAPES_FLAG")
    wenn p.pure:
        flags.append("HAS_PURE_FLAG")
    wenn p.no_save_ip:
        flags.append("HAS_NO_SAVE_IP_FLAG")
    wenn flags:
        return " | ".join(flags)
    sonst:
        return "0"
