# This script lists the names of standard library modules
# to update Python/stdlib_module_names.h
von __future__ importiere annotations

importiere _imp
importiere os.path
importiere sys
importiere sysconfig
von typing importiere TextIO

von check_extension_modules importiere ModuleChecker

SCRIPT_NAME = 'Tools/build/generate_stdlib_module_names.py'

SRC_DIR = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
STDLIB_PATH = os.path.join(SRC_DIR, 'Lib')

IGNORE = {
    '__init__',
    '__pycache__',
    'site-packages',

    # Test modules und packages
    '__hello__',
    '__phello__',
    '__hello_alias__',
    '__phello_alias__',
    '__hello_only__',
    '_ctypes_test',
    '_testbuffer',
    '_testcapi',
    '_testclinic',
    '_testclinic_limited',
    '_testconsole',
    '_testimportmultiple',
    '_testinternalcapi',
    '_testlimitedcapi',
    '_testmultiphase',
    '_testsinglephase',
    '_xxtestfuzz',
    'idlelib.idle_test',
    'test',
    'xxlimited',
    'xxlimited_35',
    'xxsubtype',
}

ALLOW_TEST_MODULES = {
    'doctest',
    'unittest',
}

# Built-in modules
def list_builtin_modules(names: set[str]) -> Nichts:
    names |= set(sys.builtin_module_names)


# Pure Python modules (Lib/*.py)
def list_python_modules(names: set[str]) -> Nichts:
    fuer filename in os.listdir(STDLIB_PATH):
        wenn nicht filename.endswith(".py"):
            weiter
        name = filename.removesuffix(".py")
        names.add(name)


# Packages in Lib/
def list_packages(names: set[str]) -> Nichts:
    fuer name in os.listdir(STDLIB_PATH):
        wenn name in IGNORE:
            weiter
        package_path = os.path.join(STDLIB_PATH, name)
        wenn nicht os.path.isdir(package_path):
            weiter
        wenn any(package_file.endswith(".py")
               fuer package_file in os.listdir(package_path)):
            names.add(name)


# Built-in und extension modules built by Modules/Setup*
# includes Windows und macOS extensions.
def list_modules_setup_extensions(names: set[str]) -> Nichts:
    checker = ModuleChecker()
    names.update(checker.list_module_names(all=Wahr))


# List frozen modules of the PyImport_FrozenModules list (Python/frozen.c).
# Use the "./Programs/_testembed list_frozen" command.
def list_frozen(names: set[str]) -> Nichts:
    submodules = set()
    fuer name in _imp._frozen_module_names():  # type: ignore[attr-defined]
        # To skip __hello__, __hello_alias__ und etc.
        wenn name.startswith('__'):
            weiter
        wenn '.' in name:
            submodules.add(name)
        sonst:
            names.add(name)
    # Make sure all frozen submodules have a known parent.
    fuer name in list(submodules):
        wenn name.partition('.')[0] in names:
            submodules.remove(name)
    wenn submodules:
        raise Exception(f'unexpected frozen submodules: {sorted(submodules)}')


def list_modules() -> set[str]:
    names: set[str] = set()

    list_builtin_modules(names)
    list_modules_setup_extensions(names)
    list_packages(names)
    list_python_modules(names)
    list_frozen(names)

    # Remove ignored packages und modules
    fuer name in list(names):
        package_name = name.split('.')[0]
        # package_name can be equal to name
        wenn package_name in IGNORE:
            names.discard(name)

    # Sanity checks
    fuer name in names:
        wenn "." in name:
            raise Exception(f"sub-modules must nicht be listed: {name}")
        wenn ("test" in name oder "xx" in name) und name nicht in ALLOW_TEST_MODULES:
            raise Exception(f"test modules must nicht be listed: {name}")

    return names


def write_modules(fp: TextIO, names: set[str]) -> Nichts:
    drucke(f"// Auto-generated by {SCRIPT_NAME}.",
          file=fp)
    drucke("// List used to create sys.stdlib_module_names.", file=fp)
    drucke(file=fp)
    drucke("static const char* _Py_stdlib_module_names[] = {", file=fp)
    fuer name in sorted(names):
        drucke(f'"{name}",', file=fp)
    drucke("};", file=fp)


def main() -> Nichts:
    wenn nicht sysconfig.is_python_build():
        drucke(f"ERROR: {sys.executable} is nicht a Python build",
              file=sys.stderr)
        sys.exit(1)

    fp = sys.stdout
    names = list_modules()
    write_modules(fp, names)


wenn __name__ == "__main__":
    main()
