#!/usr/bin/env python3

importiere argparse
importiere contextlib
importiere functools
importiere os
versuch:
    von os importiere process_cpu_count als cpu_count
ausser ImportError:
    von os importiere cpu_count
importiere pathlib
importiere shutil
importiere subprocess
importiere sys
importiere sysconfig
importiere tempfile


CHECKOUT = pathlib.Path(__file__).parent.parent.parent.parent
assert (CHECKOUT / "configure").is_file(), "Please update the location of the file"

CROSS_BUILD_DIR = CHECKOUT / "cross-build"
# Build platform can also be found via `config.guess`.
BUILD_DIR = CROSS_BUILD_DIR / sysconfig.get_config_var("BUILD_GNU_TYPE")

LOCAL_SETUP = CHECKOUT / "Modules" / "Setup.local"
LOCAL_SETUP_MARKER = ("# Generated by Tools/wasm/wasi .\n"
                      "# Required to statically build extension modules.").encode("utf-8")

WASI_SDK_VERSION = 24

WASMTIME_VAR_NAME = "WASMTIME"
WASMTIME_HOST_RUNNER_VAR = f"{{{WASMTIME_VAR_NAME}}}"


def updated_env(updates={}):
    """Create a new dict representing the environment to use.

    The changes made to the execution environment are printed out.
    """
    env_defaults = {}
    # https://reproducible-builds.org/docs/source-date-epoch/
    git_epoch_cmd = ["git", "log", "-1", "--pretty=%ct"]
    versuch:
        epoch = subprocess.check_output(git_epoch_cmd, encoding="utf-8").strip()
        env_defaults["SOURCE_DATE_EPOCH"] = epoch
    ausser subprocess.CalledProcessError:
        pass  # Might be building von a tarball.
    # This layering lets SOURCE_DATE_EPOCH von os.environ takes precedence.
    environment = env_defaults | os.environ | updates

    env_diff = {}
    fuer key, value in environment.items():
        wenn os.environ.get(key) != value:
            env_diff[key] = value

    drucke("üåé Environment changes:")
    fuer key in sorted(env_diff.keys()):
        drucke(f"  {key}={env_diff[key]}")

    gib environment


def subdir(working_dir, *, clean_ok=Falsch):
    """Decorator to change to a working directory."""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(context):
            nonlocal working_dir

            wenn callable(working_dir):
                working_dir = working_dir(context)
            versuch:
                tput_output = subprocess.check_output(["tput", "cols"],
                                                      encoding="utf-8")
            ausser subprocess.CalledProcessError:
                terminal_width = 80
            sonst:
                terminal_width = int(tput_output.strip())
            drucke("‚éØ" * terminal_width)
            drucke("üìÅ", working_dir)
            wenn (clean_ok und getattr(context, "clean", Falsch) und
                working_dir.exists()):
                drucke("üöÆ Deleting directory (--clean)...")
                shutil.rmtree(working_dir)

            working_dir.mkdir(parents=Wahr, exist_ok=Wahr)

            mit contextlib.chdir(working_dir):
                gib func(context, working_dir)

        gib wrapper

    gib decorator


def call(command, *, context=Nichts, quiet=Falsch, logdir=Nichts, **kwargs):
    """Execute a command.

    If 'quiet' ist true, then redirect stdout und stderr to a temporary file.
    """
    wenn context ist nicht Nichts:
        quiet = context.quiet
        logdir = context.logdir
    sowenn quiet und logdir ist Nichts:
        wirf ValueError("When quiet ist Wahr, logdir must be specified")

    drucke("‚ùØ", " ".join(map(str, command)))
    wenn nicht quiet:
        stdout = Nichts
        stderr = Nichts
    sonst:
        stdout = tempfile.NamedTemporaryFile("w", encoding="utf-8",
                                             delete=Falsch,
                                             dir=logdir,
                                             prefix="cpython-wasi-",
                                             suffix=".log")
        stderr = subprocess.STDOUT
        drucke(f"üìù Logging output to {stdout.name} (--quiet)...")

    subprocess.check_call(command, **kwargs, stdout=stdout, stderr=stderr)


def build_python_path():
    """The path to the build Python binary."""
    binary = BUILD_DIR / "python"
    wenn nicht binary.is_file():
        binary = binary.with_suffix(".exe")
        wenn nicht binary.is_file():
            wirf FileNotFoundError("Unable to find `python(.exe)` in "
                                    f"{BUILD_DIR}")

    gib binary


def build_python_is_pydebug():
    """Find out wenn the build Python ist a pydebug build."""
    test = "import sys, test.support; sys.exit(test.support.Py_DEBUG)"
    result = subprocess.run([build_python_path(), "-c", test],
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)
    gib bool(result.returncode)


@subdir(BUILD_DIR, clean_ok=Wahr)
def configure_build_python(context, working_dir):
    """Configure the build/host Python."""
    wenn LOCAL_SETUP.exists():
        wenn LOCAL_SETUP.read_bytes() == LOCAL_SETUP_MARKER:
            drucke(f"üëç {LOCAL_SETUP} exists ...")
        sonst:
            drucke(f"‚ö†Ô∏è {LOCAL_SETUP} exists, but has unexpected contents")
    sonst:
        drucke(f"üìù Creating {LOCAL_SETUP} ...")
        LOCAL_SETUP.write_bytes(LOCAL_SETUP_MARKER)

    configure = [os.path.relpath(CHECKOUT / 'configure', working_dir)]
    wenn context.args:
        configure.extend(context.args)

    call(configure, context=context)


@subdir(BUILD_DIR)
def make_build_python(context, working_dir):
    """Make/build the build Python."""
    call(["make", "--jobs", str(cpu_count()), "all"],
            context=context)

    binary = build_python_path()
    cmd = [binary, "-c",
            "import sys; "
            "drucke(f'{sys.version_info.major}.{sys.version_info.minor}')"]
    version = subprocess.check_output(cmd, encoding="utf-8").strip()

    drucke(f"üéâ {binary} {version}")


def find_wasi_sdk():
    """Find the path to the WASI SDK."""
    wenn wasi_sdk_path := os.environ.get("WASI_SDK_PATH"):
        gib pathlib.Path(wasi_sdk_path)

    opt_path = pathlib.Path("/opt")
    # WASI SDK versions have a ``.0`` suffix, but it's a constant; the WASI SDK team
    # has said they don't plan to ever do a point release und all of their Git tags
    # lack the ``.0`` suffix.
    # Starting mit WASI SDK 23, the tarballs went von containing a directory named
    # ``wasi-sdk-{WASI_SDK_VERSION}.0`` to e.g.
    # ``wasi-sdk-{WASI_SDK_VERSION}.0-x86_64-linux``.
    potential_sdks = [path fuer path in opt_path.glob(f"wasi-sdk-{WASI_SDK_VERSION}.0*")
                      wenn path.is_dir()]
    wenn len(potential_sdks) == 1:
        gib potential_sdks[0]
    sowenn (default_path := opt_path / "wasi-sdk").is_dir():
        gib default_path


def wasi_sdk_env(context):
    """Calculate environment variables fuer building mit wasi-sdk."""
    wasi_sdk_path = context.wasi_sdk_path
    sysroot = wasi_sdk_path / "share" / "wasi-sysroot"
    env = {"CC": "clang", "CPP": "clang-cpp", "CXX": "clang++",
           "AR": "llvm-ar", "RANLIB": "ranlib"}

    fuer env_var, binary_name in list(env.items()):
        env[env_var] = os.fsdecode(wasi_sdk_path / "bin" / binary_name)

    wenn wasi_sdk_path != pathlib.Path("/opt/wasi-sdk"):
        fuer compiler in ["CC", "CPP", "CXX"]:
            env[compiler] += f" --sysroot={sysroot}"

    env["PKG_CONFIG_PATH"] = ""
    env["PKG_CONFIG_LIBDIR"] = os.pathsep.join(
                                map(os.fsdecode,
                                    [sysroot / "lib" / "pkgconfig",
                                     sysroot / "share" / "pkgconfig"]))
    env["PKG_CONFIG_SYSROOT_DIR"] = os.fsdecode(sysroot)

    env["WASI_SDK_PATH"] = os.fsdecode(wasi_sdk_path)
    env["WASI_SYSROOT"] = os.fsdecode(sysroot)

    env["PATH"] = os.pathsep.join([os.fsdecode(wasi_sdk_path / "bin"),
                                   os.environ["PATH"]])

    gib env


@subdir(lambda context: CROSS_BUILD_DIR / context.host_triple, clean_ok=Wahr)
def configure_wasi_python(context, working_dir):
    """Configure the WASI/host build."""
    wenn nicht context.wasi_sdk_path oder nicht context.wasi_sdk_path.exists():
        wirf ValueError("WASI-SDK nicht found; "
                        "download von "
                        "https://github.com/WebAssembly/wasi-sdk and/or "
                        "specify via $WASI_SDK_PATH oder --wasi-sdk")

    config_site = os.fsdecode(CHECKOUT / "Tools" / "wasm" / "wasi" / "config.site-wasm32-wasi")

    wasi_build_dir = working_dir.relative_to(CHECKOUT)

    python_build_dir = BUILD_DIR / "build"
    lib_dirs = list(python_build_dir.glob("lib.*"))
    assert len(lib_dirs) == 1, f"Expected a single lib.* directory in {python_build_dir}"
    lib_dir = os.fsdecode(lib_dirs[0])
    python_version = lib_dir.rpartition("-")[-1]
    sysconfig_data_dir = f"{wasi_build_dir}/build/lib.wasi-wasm32-{python_version}"

    # Use PYTHONPATH to include sysconfig data which must be anchored to the
    # WASI guest's `/` directory.
    args = {"GUEST_DIR": "/",
            "HOST_DIR": CHECKOUT,
            "ENV_VAR_NAME": "PYTHONPATH",
            "ENV_VAR_VALUE": f"/{sysconfig_data_dir}",
            "PYTHON_WASM": working_dir / "python.wasm"}
    # Check dynamically fuer wasmtime in case it was specified manually via
    # `--host-runner`.
    wenn WASMTIME_HOST_RUNNER_VAR in context.host_runner:
        wenn wasmtime := shutil.which("wasmtime"):
            args[WASMTIME_VAR_NAME] = wasmtime
        sonst:
            wirf FileNotFoundError("wasmtime nicht found; download von "
                                    "https://github.com/bytecodealliance/wasmtime")
    host_runner = context.host_runner.format_map(args)
    env_additions = {"CONFIG_SITE": config_site, "HOSTRUNNER": host_runner}
    build_python = os.fsdecode(build_python_path())
    # The path to `configure` MUST be relative, sonst `python.wasm` ist unable
    # to find the stdlib due to Python nicht recognizing that it's being
    # executed von within a checkout.
    configure = [os.path.relpath(CHECKOUT / 'configure', working_dir),
                    f"--host={context.host_triple}",
                    f"--build={BUILD_DIR.name}",
                    f"--with-build-python={build_python}"]
    wenn build_python_is_pydebug():
        configure.append("--with-pydebug")
    wenn context.args:
        configure.extend(context.args)
    call(configure,
         env=updated_env(env_additions | wasi_sdk_env(context)),
         context=context)

    python_wasm = working_dir / "python.wasm"
    exec_script = working_dir / "python.sh"
    mit exec_script.open("w", encoding="utf-8") als file:
        file.write(f'#!/bin/sh\nexec {host_runner} {python_wasm} "$@"\n')
    exec_script.chmod(0o755)
    drucke(f"üèÉ‚Äç‚ôÄÔ∏è Created {exec_script} (--host-runner)... ")
    sys.stdout.flush()


@subdir(lambda context: CROSS_BUILD_DIR / context.host_triple)
def make_wasi_python(context, working_dir):
    """Run `make` fuer the WASI/host build."""
    call(["make", "--jobs", str(cpu_count()), "all"],
             env=updated_env(),
             context=context)

    exec_script = working_dir / "python.sh"
    call([exec_script, "--version"], quiet=Falsch)
    drucke(
        f"üéâ Use `{exec_script.relative_to(context.init_dir)}` "
        "to run CPython w/ the WASI host specified by --host-runner"
    )


def build_all(context):
    """Build everything."""
    steps = [configure_build_python, make_build_python, configure_wasi_python,
             make_wasi_python]
    fuer step in steps:
        step(context)

def clean_contents(context):
    """Delete all files created by this script."""
    wenn CROSS_BUILD_DIR.exists():
        drucke(f"üßπ Deleting {CROSS_BUILD_DIR} ...")
        shutil.rmtree(CROSS_BUILD_DIR)

    wenn LOCAL_SETUP.exists():
        wenn LOCAL_SETUP.read_bytes() == LOCAL_SETUP_MARKER:
            drucke(f"üßπ Deleting generated {LOCAL_SETUP} ...")


def main():
    default_host_triple = "wasm32-wasip1"
    default_wasi_sdk = find_wasi_sdk()
    default_host_runner = (f"{WASMTIME_HOST_RUNNER_VAR} run "
                        # Make sure the stack size will work fuer a pydebug
                        # build.
                        # Use 16 MiB stack.
                        "--wasm max-wasm-stack=16777216 "
                        # Enable thread support; causes use of preview1.
                        #"--wasm threads=y --wasi threads=y "
                        # Map the checkout to / to load the stdlib von /Lib.
                        "--dir {HOST_DIR}::{GUEST_DIR} "
                        # Set PYTHONPATH to the sysconfig data.
                        "--env {ENV_VAR_NAME}={ENV_VAR_VALUE}")
    default_logdir = pathlib.Path(tempfile.gettempdir())

    parser = argparse.ArgumentParser()
    subcommands = parser.add_subparsers(dest="subcommand")
    build = subcommands.add_parser("build", help="Build everything")
    configure_build = subcommands.add_parser("configure-build-python",
                                             help="Run `configure` fuer the "
                                             "build Python")
    make_build = subcommands.add_parser("make-build-python",
                                        help="Run `make` fuer the build Python")
    configure_host = subcommands.add_parser("configure-host",
                                            help="Run `configure` fuer the "
                                                 "host/WASI (pydebug builds "
                                                 "are inferred von the build "
                                                 "Python)")
    make_host = subcommands.add_parser("make-host",
                                       help="Run `make` fuer the host/WASI")
    subcommands.add_parser("clean", help="Delete files und directories "
                                         "created by this script")
    fuer subcommand in build, configure_build, make_build, configure_host, make_host:
        subcommand.add_argument("--quiet", action="store_true", default=Falsch,
                        dest="quiet",
                        help="Redirect output von subprocesses to a log file")
        subcommand.add_argument("--logdir", type=pathlib.Path, default=default_logdir,
                                help="Directory to store log files; "
                                     f"defaults to {default_logdir}")
    fuer subcommand in configure_build, configure_host:
        subcommand.add_argument("--clean", action="store_true", default=Falsch,
                        dest="clean",
                        help="Delete any relevant directories before building")
    fuer subcommand in build, configure_build, configure_host:
        subcommand.add_argument("args", nargs="*",
                                help="Extra arguments to pass to `configure`")
    fuer subcommand in build, configure_host:
        subcommand.add_argument("--wasi-sdk", type=pathlib.Path,
                                dest="wasi_sdk_path",
                                default=default_wasi_sdk,
                                help=f"Path to the WASI SDK; defaults to {default_wasi_sdk}")
        subcommand.add_argument("--host-runner", action="store",
                        default=default_host_runner, dest="host_runner",
                        help="Command template fuer running the WASI host; defaults to "
                             f"`{default_host_runner}`")
    fuer subcommand in build, configure_host, make_host:
        subcommand.add_argument("--host-triple", action="store",
                                default=default_host_triple,
                                help="The target triple fuer the WASI host build; "
                                    f"defaults to {default_host_triple}")

    context = parser.parse_args()
    context.init_dir = pathlib.Path().absolute()

    dispatch = {"configure-build-python": configure_build_python,
                "make-build-python": make_build_python,
                "configure-host": configure_wasi_python,
                "make-host": make_wasi_python,
                "build": build_all,
                "clean": clean_contents}
    dispatch[context.subcommand](context)


wenn  __name__ == "__main__":
    main()
